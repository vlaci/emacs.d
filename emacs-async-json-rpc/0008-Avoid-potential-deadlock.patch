From 8cea98e94c0fd170c26a2b3da9ed2888b55ce084 Mon Sep 17 00:00:00 2001
From: Sebastian Sturm <s.sturm@arkona-technologies.de>
Date: Sun, 26 Feb 2023 20:30:36 +0100
Subject: [PATCH 08/13] Avoid potential deadlock

ssp_send is blocking, and holds the handle mutex, so previously some
other methods (personally, I've always seen this with json-rpc-pid)
might deadlock trying to lock the handle mutex while it is being held by
send. To circumvent this, ssp_send now uses a send timeout (of 10ms by
default) and repeatedly calls send() in a loop until either the entire
message has been sent, or until a cancel flag has been set. This way,
json-rpc-shutdown can set said cancel flag and then lock the mutex,
which should never take longer than ~1 send timeout. Since the cancel
flag is a bool and monotonic, I assume it can safely be changed
unsynchronized.  Probably the separate cancel flag should later be done
away with (if the present approach is deemed reasonable), as send could
just as well consider the preexisting state.done member.

For json-rpc-pid, the pid is copied from the ssp handle to the json rpc
state on initialization (since it's a write-once value anyway), so
json-rpc-pid doesn't need to lock the handle mutex any longer. For
json-rpc-alive-p I haven't seen any use so far, so I simply deleted it.
---
 src/json.c   | 788 +++++++++++++++++++++++++--------------------------
 src/spsupr.c | 393 ++++++++++++++-----------
 src/spsupr.h |  23 +-
 3 files changed, 626 insertions(+), 578 deletions(-)

diff --git a/src/json.c b/src/json.c
index dc57d1740b0..d137c9a7501 100644
--- a/src/json.c
+++ b/src/json.c
@@ -42,22 +42,22 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 const int BUFFER_SIZE = 1000;
 
 #ifdef WINDOWSNT
-# include <windows.h>
-# include "w32common.h"
-# include "w32.h"
+#include <windows.h>
+#include "w32common.h"
+#include "w32.h"
 
 DEF_DLL_FN (void, json_set_alloc_funcs,
 	    (json_malloc_t malloc_fn, json_free_t free_fn));
-DEF_DLL_FN (void, json_delete, (json_t *json));
-DEF_DLL_FN (json_t *, json_array, (void));
-DEF_DLL_FN (int, json_array_append_new, (json_t *array, json_t *value));
+DEF_DLL_FN (void, json_delete, (json_t * json));
+DEF_DLL_FN (json_t *, json_array, (void) );
+DEF_DLL_FN (int, json_array_append_new, (json_t * array, json_t *value));
 DEF_DLL_FN (size_t, json_array_size, (const json_t *array));
-DEF_DLL_FN (json_t *, json_object, (void));
+DEF_DLL_FN (json_t *, json_object, (void) );
 DEF_DLL_FN (int, json_object_set_new,
-	    (json_t *object, const char *key, json_t *value));
-DEF_DLL_FN (json_t *, json_null, (void));
-DEF_DLL_FN (json_t *, json_true, (void));
-DEF_DLL_FN (json_t *, json_false, (void));
+	    (json_t * object, const char *key, json_t *value));
+DEF_DLL_FN (json_t *, json_null, (void) );
+DEF_DLL_FN (json_t *, json_true, (void) );
+DEF_DLL_FN (json_t *, json_false, (void) );
 DEF_DLL_FN (json_t *, json_integer, (json_int_t value));
 DEF_DLL_FN (json_t *, json_real, (double value));
 DEF_DLL_FN (json_t *, json_stringn, (const char *value, size_t len));
@@ -73,10 +73,10 @@ DEF_DLL_FN (json_t *, json_array_get, (const json_t *array, size_t index));
 DEF_DLL_FN (json_t *, json_object_get, (const json_t *object, const char *key));
 DEF_DLL_FN (size_t, json_object_size, (const json_t *object));
 DEF_DLL_FN (const char *, json_object_iter_key, (void *iter));
-DEF_DLL_FN (void *, json_object_iter, (json_t *object));
+DEF_DLL_FN (void *, json_object_iter, (json_t * object));
 DEF_DLL_FN (json_t *, json_object_iter_value, (void *iter));
 DEF_DLL_FN (void *, json_object_key_to_iter, (const char *key));
-DEF_DLL_FN (void *, json_object_iter_next, (json_t *object, void *iter));
+DEF_DLL_FN (void *, json_object_iter_next, (json_t * object, void *iter));
 DEF_DLL_FN (json_t *, json_loads,
 	    (const char *input, size_t flags, json_error_t *error));
 DEF_DLL_FN (json_t *, json_load_callback,
@@ -84,7 +84,8 @@ DEF_DLL_FN (json_t *, json_load_callback,
 	     json_error_t *error));
 
 /* This is called by json_decref, which is an inline function.  */
-void json_delete(json_t *json)
+void
+json_delete (json_t *json)
 {
   fn_json_delete (json);
 }
@@ -163,7 +164,7 @@ init_json_functions (void)
 #define json_loads fn_json_loads
 #define json_load_callback fn_json_load_callback
 
-#endif	/* WINDOWSNT */
+#endif /* WINDOWSNT */
 
 /* We install a custom allocator so that we can avoid objects larger
    than PTRDIFF_MAX.  Such objects wouldn't play well with the rest of
@@ -217,7 +218,7 @@ json_has_suffix (const char *string, const char *suffix)
   size_t string_len = strlen (string);
   size_t suffix_len = strlen (suffix);
   return string_len >= suffix_len
-    && memcmp (string + string_len - suffix_len, suffix, suffix_len) == 0;
+	 && memcmp (string + string_len - suffix_len, suffix, suffix_len) == 0;
 }
 
 #endif
@@ -274,10 +275,9 @@ json_parse_error (const json_error_t *error)
     symbol = Qjson_parse_error;
 #endif
   xsignal (symbol,
-           list5 (build_string_from_utf8 (error->text),
-                  build_string_from_utf8 (error->source),
-		  INT_TO_INTEGER (error->line),
-                  INT_TO_INTEGER (error->column),
+	   list5 (build_string_from_utf8 (error->text),
+		  build_string_from_utf8 (error->source),
+		  INT_TO_INTEGER (error->line), INT_TO_INTEGER (error->column),
 		  INT_TO_INTEGER (error->position)));
 }
 
@@ -295,7 +295,7 @@ check_string_without_embedded_nulls (Lisp_Object object)
 {
   CHECK_STRING (object);
   CHECK_TYPE (memchr (SDATA (object), '\0', SBYTES (object)) == NULL,
-              Qstring_without_embedded_nulls_p, object);
+	      Qstring_without_embedded_nulls_p, object);
 }
 
 /* Signal an error of type `json-out-of-memory' if OBJECT is
@@ -318,32 +318,35 @@ json_check_utf8 (Lisp_Object string)
   CHECK_TYPE (utf8_string_p (string), Qutf_8_string_p, string);
 }
 
-enum json_object_type {
+enum json_object_type
+{
   json_object_hashtable,
   json_object_alist,
   json_object_plist
 };
 
-enum json_array_type {
+enum json_array_type
+{
   json_array_array,
   json_array_list
 };
 
-struct json_configuration {
+struct json_configuration
+{
   enum json_object_type object_type;
   enum json_array_type array_type;
   Lisp_Object null_object;
   Lisp_Object false_object;
 };
 
-static json_t *lisp_to_json (Lisp_Object,
-                             const struct json_configuration *conf);
+static json_t *
+lisp_to_json (Lisp_Object, const struct json_configuration *conf);
 
 /* Convert a Lisp object to a nonscalar JSON object (array or object).  */
 
 static json_t *
 lisp_to_json_nonscalar_1 (Lisp_Object lisp,
-                          const struct json_configuration *conf)
+			  const struct json_configuration *conf)
 {
   json_t *json;
   specpdl_ref count;
@@ -355,13 +358,12 @@ lisp_to_json_nonscalar_1 (Lisp_Object lisp,
       count = SPECPDL_INDEX ();
       record_unwind_protect_ptr (json_release_object, json);
       for (ptrdiff_t i = 0; i < size; ++i)
-        {
-          int status
-            = json_array_append_new (json, lisp_to_json (AREF (lisp, i),
-                                                         conf));
-          if (status == -1)
-            json_out_of_memory ();
-        }
+	{
+	  int status
+	    = json_array_append_new (json, lisp_to_json (AREF (lisp, i), conf));
+	  if (status == -1)
+	    json_out_of_memory ();
+	}
       eassert (json_array_size (json) == size);
     }
   else if (HASH_TABLE_P (lisp))
@@ -371,32 +373,32 @@ lisp_to_json_nonscalar_1 (Lisp_Object lisp,
       count = SPECPDL_INDEX ();
       record_unwind_protect_ptr (json_release_object, json);
       for (ptrdiff_t i = 0; i < HASH_TABLE_SIZE (h); ++i)
-        {
-          Lisp_Object key = HASH_KEY (h, i);
-          if (!BASE_EQ (key, Qunbound))
-            {
-              CHECK_STRING (key);
-              Lisp_Object ekey = json_encode (key);
-              /* We can't specify the length, so the string must be
+	{
+	  Lisp_Object key = HASH_KEY (h, i);
+	  if (!BASE_EQ (key, Qunbound))
+	    {
+	      CHECK_STRING (key);
+	      Lisp_Object ekey = json_encode (key);
+	      /* We can't specify the length, so the string must be
 		 null-terminated.  */
-              check_string_without_embedded_nulls (ekey);
-              const char *key_str = SSDATA (ekey);
-              /* Reject duplicate keys.  These are possible if the hash
+	      check_string_without_embedded_nulls (ekey);
+	      const char *key_str = SSDATA (ekey);
+	      /* Reject duplicate keys.  These are possible if the hash
 		 table test is not `equal'.  */
-              if (json_object_get (json, key_str) != NULL)
-                wrong_type_argument (Qjson_value_p, lisp);
-              int status
-                = json_object_set_new (json, key_str,
-                                       lisp_to_json (HASH_VALUE (h, i), conf));
-              if (status == -1)
-                {
-                  /* A failure can be caused either by an invalid key or
-                   by low memory.  */
-                  json_check_utf8 (ekey);
-                  json_out_of_memory ();
-                }
-            }
-        }
+	      if (json_object_get (json, key_str) != NULL)
+		wrong_type_argument (Qjson_value_p, lisp);
+	      int status
+		= json_object_set_new (json, key_str,
+				       lisp_to_json (HASH_VALUE (h, i), conf));
+	      if (status == -1)
+		{
+		  /* A failure can be caused either by an invalid key or
+		   by low memory.  */
+		  json_check_utf8 (ekey);
+		  json_out_of_memory ();
+		}
+	    }
+	}
     }
   else if (NILP (lisp))
     return json_check (json_object ());
@@ -408,46 +410,45 @@ lisp_to_json_nonscalar_1 (Lisp_Object lisp,
       record_unwind_protect_ptr (json_release_object, json);
       bool is_plist = !CONSP (XCAR (tail));
       FOR_EACH_TAIL (tail)
-        {
-          const char *key_str;
-          Lisp_Object value;
-          Lisp_Object key_symbol;
-          if (is_plist)
-            {
-              key_symbol = XCAR (tail);
-              tail = XCDR (tail);
-              CHECK_CONS (tail);
-              value = XCAR (tail);
-            }
-          else
-            {
-              Lisp_Object pair = XCAR (tail);
-              CHECK_CONS (pair);
-              key_symbol = XCAR (pair);
-              value = XCDR (pair);
-            }
-          CHECK_SYMBOL (key_symbol);
-          Lisp_Object key = SYMBOL_NAME (key_symbol);
-          /* We can't specify the length, so the string must be
-             null-terminated.  */
-          check_string_without_embedded_nulls (key);
-          key_str = SSDATA (key);
-          /* In plists, ensure leading ":" in keys is stripped.  It
-             will be reconstructed later in `json_to_lisp'.*/
-          if (is_plist && ':' == key_str[0] && key_str[1])
-            {
-              key_str = &key_str[1];
-            }
-          /* Only add element if key is not already present.  */
-          if (json_object_get (json, key_str) == NULL)
-            {
-              int status
-                = json_object_set_new (json, key_str, lisp_to_json (value,
-                                                                    conf));
-              if (status == -1)
-                json_out_of_memory ();
-            }
-        }
+      {
+	const char *key_str;
+	Lisp_Object value;
+	Lisp_Object key_symbol;
+	if (is_plist)
+	  {
+	    key_symbol = XCAR (tail);
+	    tail = XCDR (tail);
+	    CHECK_CONS (tail);
+	    value = XCAR (tail);
+	  }
+	else
+	  {
+	    Lisp_Object pair = XCAR (tail);
+	    CHECK_CONS (pair);
+	    key_symbol = XCAR (pair);
+	    value = XCDR (pair);
+	  }
+	CHECK_SYMBOL (key_symbol);
+	Lisp_Object key = SYMBOL_NAME (key_symbol);
+	/* We can't specify the length, so the string must be
+	   null-terminated.  */
+	check_string_without_embedded_nulls (key);
+	key_str = SSDATA (key);
+	/* In plists, ensure leading ":" in keys is stripped.  It
+	   will be reconstructed later in `json_to_lisp'.*/
+	if (is_plist && ':' == key_str[0] && key_str[1])
+	  {
+	    key_str = &key_str[1];
+	  }
+	/* Only add element if key is not already present.  */
+	if (json_object_get (json, key_str) == NULL)
+	  {
+	    int status
+	      = json_object_set_new (json, key_str, lisp_to_json (value, conf));
+	    if (status == -1)
+	      json_out_of_memory ();
+	  }
+      }
       CHECK_LIST_END (tail, lisp);
     }
   else
@@ -463,8 +464,7 @@ lisp_to_json_nonscalar_1 (Lisp_Object lisp,
    hashtable, alist, or plist.  */
 
 static json_t *
-lisp_to_json_nonscalar (Lisp_Object lisp,
-                        const struct json_configuration *conf)
+lisp_to_json_nonscalar (Lisp_Object lisp, const struct json_configuration *conf)
 {
   if (++lisp_eval_depth > max_lisp_eval_depth)
     xsignal0 (Qjson_object_too_deep);
@@ -500,12 +500,12 @@ lisp_to_json (Lisp_Object lisp, const struct json_configuration *conf)
       Lisp_Object encoded = json_encode (lisp);
       json_t *json = json_stringn (SSDATA (encoded), SBYTES (encoded));
       if (json == NULL)
-        {
-          /* A failure can be caused either by an invalid string or by
-             low memory.  */
-          json_check_utf8 (encoded);
-          json_out_of_memory ();
-        }
+	{
+	  /* A failure can be caused either by an invalid string or by
+	     low memory.  */
+	  json_check_utf8 (encoded);
+	  json_out_of_memory ();
+	}
       return json;
     }
 
@@ -514,54 +514,49 @@ lisp_to_json (Lisp_Object lisp, const struct json_configuration *conf)
 }
 
 static void
-json_parse_args (ptrdiff_t nargs,
-                 Lisp_Object *args,
-                 struct json_configuration *conf,
-                 bool parse_object_types)
+json_parse_args (ptrdiff_t nargs, Lisp_Object *args,
+		 struct json_configuration *conf, bool parse_object_types)
 {
   if ((nargs % 2) != 0)
     wrong_type_argument (Qplistp, Flist (nargs, args));
 
   /* Start from the back so keyword values appearing
      first take precedence. */
-  for (ptrdiff_t i = nargs; i > 0; i -= 2) {
-    Lisp_Object key = args[i - 2];
-    Lisp_Object value = args[i - 1];
-    if (parse_object_types && EQ (key, QCobject_type))
-      {
-        if (EQ (value, Qhash_table))
-          conf->object_type = json_object_hashtable;
-        else if (EQ (value, Qalist))
-          conf->object_type = json_object_alist;
-        else if (EQ (value, Qplist))
-          conf->object_type = json_object_plist;
-        else
-          wrong_choice (list3 (Qhash_table, Qalist, Qplist), value);
-      }
-    else if (parse_object_types && EQ (key, QCarray_type))
-      {
-        if (EQ (value, Qarray))
-          conf->array_type = json_array_array;
-        else if (EQ (value, Qlist))
-          conf->array_type = json_array_list;
-        else
-          wrong_choice (list2 (Qarray, Qlist), value);
-      }
-    else if (EQ (key, QCnull_object))
-      conf->null_object = value;
-    else if (EQ (key, QCfalse_object))
-      conf->false_object = value;
-    else if (parse_object_types)
-      wrong_choice (list4 (QCobject_type,
-                           QCarray_type,
-                           QCnull_object,
-                           QCfalse_object),
-                    value);
-    else
-      wrong_choice (list2 (QCnull_object,
-                           QCfalse_object),
-                    value);
-  }
+  for (ptrdiff_t i = nargs; i > 0; i -= 2)
+    {
+      Lisp_Object key = args[i - 2];
+      Lisp_Object value = args[i - 1];
+      if (parse_object_types && EQ (key, QCobject_type))
+	{
+	  if (EQ (value, Qhash_table))
+	    conf->object_type = json_object_hashtable;
+	  else if (EQ (value, Qalist))
+	    conf->object_type = json_object_alist;
+	  else if (EQ (value, Qplist))
+	    conf->object_type = json_object_plist;
+	  else
+	    wrong_choice (list3 (Qhash_table, Qalist, Qplist), value);
+	}
+      else if (parse_object_types && EQ (key, QCarray_type))
+	{
+	  if (EQ (value, Qarray))
+	    conf->array_type = json_array_array;
+	  else if (EQ (value, Qlist))
+	    conf->array_type = json_array_list;
+	  else
+	    wrong_choice (list2 (Qarray, Qlist), value);
+	}
+      else if (EQ (key, QCnull_object))
+	conf->null_object = value;
+      else if (EQ (key, QCfalse_object))
+	conf->false_object = value;
+      else if (parse_object_types)
+	wrong_choice (list4 (QCobject_type, QCarray_type, QCnull_object,
+			     QCfalse_object),
+		      value);
+      else
+	wrong_choice (list2 (QCnull_object, QCfalse_object), value);
+    }
 }
 
 static bool
@@ -576,7 +571,7 @@ json_available_p (void)
       Vlibrary_cache = Fcons (Fcons (Qjson, status), Vlibrary_cache);
     }
   return json_initialized;
-#else  /* !WINDOWSNT */
+#else /* !WINDOWSNT */
   return true;
 #endif
 }
@@ -592,11 +587,9 @@ ensure_json_available (void)
 #endif
 
 DEFUN ("json--available-p", Fjson__available_p, Sjson__available_p, 0, 0, NULL,
-       doc: /* Return non-nil if libjansson is available (internal use only).  */)
-  (void)
-{
-  return json_available_p () ? Qt : Qnil;
-}
+       doc
+       : /* Return non-nil if libjansson is available (internal use only).  */)
+(void) { return json_available_p () ? Qt : Qnil; }
 
 DEFUN ("json-serialize", Fjson_serialize, Sjson_serialize, 1, MANY,
        NULL,
@@ -625,7 +618,7 @@ In you specify the same value for `:null-object' and `:false-object',
 a potentially ambiguous situation, the JSON output will not contain
 any JSON false values.
 usage: (json-serialize OBJECT &rest ARGS)  */)
-     (ptrdiff_t nargs, Lisp_Object *args)
+(ptrdiff_t nargs, Lisp_Object *args)
 {
   specpdl_ref count = SPECPDL_INDEX ();
 
@@ -633,8 +626,8 @@ usage: (json-serialize OBJECT &rest ARGS)  */)
   ensure_json_available ();
 #endif
 
-  struct json_configuration conf =
-    {json_object_hashtable, json_array_array, QCnull, QCfalse};
+  struct json_configuration conf
+    = {json_object_hashtable, json_array_array, QCnull, QCfalse};
   json_parse_args (nargs - 1, args + 1, &conf, false);
 
   json_t *json = lisp_to_json (args[0], &conf);
@@ -713,7 +706,7 @@ json_insert_callback (const char *buffer, size_t size, void *data)
   struct json_buffer_and_size buffer_and_size
     = {.buffer = buffer, .size = size, .inserted_bytes = d->inserted_bytes};
   d->error = internal_catch_all (json_insert, &buffer_and_size,
-                                 json_handle_nonlocal_exit);
+				 json_handle_nonlocal_exit);
   d->inserted_bytes = buffer_and_size.inserted_bytes;
   return NILP (d->error) ? 0 : -1;
 }
@@ -725,7 +718,7 @@ This is the same as (insert (json-serialize OBJECT)), but potentially
 faster.  See the function `json-serialize' for allowed values of
 OBJECT.
 usage: (json-insert OBJECT &rest ARGS)  */)
-     (ptrdiff_t nargs, Lisp_Object *args)
+(ptrdiff_t nargs, Lisp_Object *args)
 {
   specpdl_ref count = SPECPDL_INDEX ();
 
@@ -733,8 +726,8 @@ usage: (json-insert OBJECT &rest ARGS)  */)
   ensure_json_available ();
 #endif
 
-  struct json_configuration conf =
-    {json_object_hashtable, json_array_array, QCnull, QCfalse};
+  struct json_configuration conf
+    = {json_object_hashtable, json_array_array, QCnull, QCfalse};
   json_parse_args (nargs - 1, args + 1, &conf, false);
 
   json_t *json = lisp_to_json (args[0], &conf);
@@ -747,13 +740,13 @@ usage: (json-insert OBJECT &rest ARGS)  */)
   /* Could have used json_dumpb, but that became available only in
      Jansson 2.10, whereas we want to support 2.7 and upward.  */
   int status = json_dump_callback (json, json_insert_callback, &data,
-                                   JSON_COMPACT | JSON_ENCODE_ANY);
+				   JSON_COMPACT | JSON_ENCODE_ANY);
   if (status == -1)
     {
       if (CONSP (data.error))
-        xsignal (XCAR (data.error), XCDR (data.error));
+	xsignal (XCAR (data.error), XCDR (data.error));
       else
-        json_out_of_memory ();
+	json_out_of_memory ();
     }
 
   ptrdiff_t inserted = 0;
@@ -767,30 +760,27 @@ usage: (json-insert OBJECT &rest ARGS)  */)
 	 byte sequences, they will be represented by raw bytes in the
 	 buffer text.  */
       setup_coding_system (Qutf_8_unix, &coding);
-      coding.dst_multibyte =
-	!NILP (BVAR (current_buffer, enable_multibyte_characters));
+      coding.dst_multibyte
+	= !NILP (BVAR (current_buffer, enable_multibyte_characters));
       if (CODING_MAY_REQUIRE_DECODING (&coding))
 	{
-          /* Now we have all the new bytes at the beginning of the gap,
-             but `decode_coding_gap` needs them at the end of the gap, so
-             we need to move them.  */
-          memmove (GAP_END_ADDR - inserted_bytes, GPT_ADDR, inserted_bytes);
+	  /* Now we have all the new bytes at the beginning of the gap,
+	     but `decode_coding_gap` needs them at the end of the gap, so
+	     we need to move them.  */
+	  memmove (GAP_END_ADDR - inserted_bytes, GPT_ADDR, inserted_bytes);
 	  decode_coding_gap (&coding, inserted_bytes);
 	  inserted = coding.produced_char;
 	}
       else
 	{
-          /* Make the inserted text part of the buffer, as unibyte text.  */
-          eassert (NILP (BVAR (current_buffer, enable_multibyte_characters)));
-          insert_from_gap_1 (inserted_bytes, inserted_bytes, false);
+	  /* Make the inserted text part of the buffer, as unibyte text.  */
+	  eassert (NILP (BVAR (current_buffer, enable_multibyte_characters)));
+	  insert_from_gap_1 (inserted_bytes, inserted_bytes, false);
 
 	  /* The target buffer is unibyte, so we don't need to decode.  */
-	  invalidate_buffer_caches (current_buffer,
-				    PT, PT + inserted_bytes);
-	  adjust_after_insert (PT, PT_BYTE,
-			       PT + inserted_bytes,
-			       PT_BYTE + inserted_bytes,
-			       inserted_bytes);
+	  invalidate_buffer_caches (current_buffer, PT, PT + inserted_bytes);
+	  adjust_after_insert (PT, PT_BYTE, PT + inserted_bytes,
+			       PT_BYTE + inserted_bytes, inserted_bytes);
 	  inserted = inserted_bytes;
 	}
     }
@@ -810,7 +800,7 @@ usage: (json-insert OBJECT &rest ARGS)  */)
 /* Convert a JSON object to a Lisp object.  */
 
 static Lisp_Object ARG_NONNULL ((1))
-json_to_lisp (json_t *json, const struct json_configuration *conf)
+  json_to_lisp (json_t *json, const struct json_configuration *conf)
 {
   switch (json_typeof (json))
     {
@@ -820,8 +810,7 @@ json_to_lisp (json_t *json, const struct json_configuration *conf)
       return conf->false_object;
     case JSON_TRUE:
       return Qt;
-    case JSON_INTEGER:
-      {
+      case JSON_INTEGER: {
 	json_int_t i = json_integer_value (json);
 	return INT_TO_INTEGER (i);
       }
@@ -830,117 +819,109 @@ json_to_lisp (json_t *json, const struct json_configuration *conf)
     case JSON_STRING:
       return make_string_from_utf8 (json_string_value (json),
 				    json_string_length (json));
-    case JSON_ARRAY:
-      {
-        if (++lisp_eval_depth > max_lisp_eval_depth)
-          xsignal0 (Qjson_object_too_deep);
-        size_t size = json_array_size (json);
-        if (PTRDIFF_MAX < size)
-          overflow_error ();
-        Lisp_Object result;
-        switch (conf->array_type)
-          {
-          case json_array_array:
-            {
-              result = make_vector (size, Qunbound);
-              for (ptrdiff_t i = 0; i < size; ++i)
-                {
-                  rarely_quit (i);
-                  ASET (result, i,
-                        json_to_lisp (json_array_get (json, i), conf));
-                }
-              break;
-            }
-          case json_array_list:
-            {
-              result = Qnil;
-              for (ptrdiff_t i = size - 1; i >= 0; --i)
-                {
-                  rarely_quit (i);
-                  result = Fcons (json_to_lisp (json_array_get (json, i), conf),
-                                  result);
-                }
-              break;
-            }
-          default:
-            /* Can't get here.  */
-            emacs_abort ();
-          }
-        --lisp_eval_depth;
-        return result;
+      case JSON_ARRAY: {
+	if (++lisp_eval_depth > max_lisp_eval_depth)
+	  xsignal0 (Qjson_object_too_deep);
+	size_t size = json_array_size (json);
+	if (PTRDIFF_MAX < size)
+	  overflow_error ();
+	Lisp_Object result;
+	switch (conf->array_type)
+	  {
+	    case json_array_array: {
+	      result = make_vector (size, Qunbound);
+	      for (ptrdiff_t i = 0; i < size; ++i)
+		{
+		  rarely_quit (i);
+		  ASET (result, i,
+			json_to_lisp (json_array_get (json, i), conf));
+		}
+	      break;
+	    }
+	    case json_array_list: {
+	      result = Qnil;
+	      for (ptrdiff_t i = size - 1; i >= 0; --i)
+		{
+		  rarely_quit (i);
+		  result = Fcons (json_to_lisp (json_array_get (json, i), conf),
+				  result);
+		}
+	      break;
+	    }
+	  default:
+	    /* Can't get here.  */
+	    emacs_abort ();
+	  }
+	--lisp_eval_depth;
+	return result;
       }
-    case JSON_OBJECT:
-      {
-        if (++lisp_eval_depth > max_lisp_eval_depth)
-          xsignal0 (Qjson_object_too_deep);
-        Lisp_Object result;
-        switch (conf->object_type)
-          {
-          case json_object_hashtable:
-            {
-              size_t size = json_object_size (json);
-              if (FIXNUM_OVERFLOW_P (size))
-                overflow_error ();
-              result = CALLN (Fmake_hash_table, QCtest, Qequal, QCsize,
-                              make_fixed_natnum (size));
-              struct Lisp_Hash_Table *h = XHASH_TABLE (result);
-              const char *key_str;
-              json_t *value;
-              json_object_foreach (json, key_str, value)
-                {
-		  Lisp_Object key = build_string_from_utf8 (key_str), hash;
-                  ptrdiff_t i = hash_lookup (h, key, &hash);
-                  /* Keys in JSON objects are unique, so the key can't
-                     be present yet.  */
-                  eassert (i < 0);
-                  hash_put (h, key, json_to_lisp (value, conf), hash);
-                }
-              break;
-            }
-          case json_object_alist:
-            {
-              result = Qnil;
-              const char *key_str;
-              json_t *value;
-              json_object_foreach (json, key_str, value)
-                {
-                  Lisp_Object key
-		    = Fintern (build_string_from_utf8 (key_str), Qnil);
-                  result
-                    = Fcons (Fcons (key, json_to_lisp (value, conf)),
-                             result);
-                }
-              result = Fnreverse (result);
-              break;
-            }
-          case json_object_plist:
-            {
-              result = Qnil;
-              const char *key_str;
-              json_t *value;
-              json_object_foreach (json, key_str, value)
-                {
-                  USE_SAFE_ALLOCA;
-                  ptrdiff_t key_str_len = strlen (key_str);
-                  char *keyword_key_str = SAFE_ALLOCA (1 + key_str_len + 1);
-                  keyword_key_str[0] = ':';
-                  strcpy (&keyword_key_str[1], key_str);
-                  Lisp_Object key = intern_1 (keyword_key_str, key_str_len + 1);
-                  /* Build the plist as value-key since we're going to
-                     reverse it in the end.*/
-                  result = Fcons (key, result);
-                  result = Fcons (json_to_lisp (value, conf), result);
-                  SAFE_FREE ();
-                }
-              result = Fnreverse (result);
-              break;
-            }
-          default:
-            /* Can't get here.  */
-            emacs_abort ();
-          }
-        --lisp_eval_depth;
-        return result;
+      case JSON_OBJECT: {
+	if (++lisp_eval_depth > max_lisp_eval_depth)
+	  xsignal0 (Qjson_object_too_deep);
+	Lisp_Object result;
+	switch (conf->object_type)
+	  {
+	    case json_object_hashtable: {
+	      size_t size = json_object_size (json);
+	      if (FIXNUM_OVERFLOW_P (size))
+		overflow_error ();
+	      result = CALLN (Fmake_hash_table, QCtest, Qequal, QCsize,
+			      make_fixed_natnum (size));
+	      struct Lisp_Hash_Table *h = XHASH_TABLE (result);
+	      const char *key_str;
+	      json_t *value;
+	      json_object_foreach (json, key_str, value)
+	      {
+		Lisp_Object key = build_string_from_utf8 (key_str), hash;
+		ptrdiff_t i = hash_lookup (h, key, &hash);
+		/* Keys in JSON objects are unique, so the key can't
+		   be present yet.  */
+		eassert (i < 0);
+		hash_put (h, key, json_to_lisp (value, conf), hash);
+	      }
+	      break;
+	    }
+	    case json_object_alist: {
+	      result = Qnil;
+	      const char *key_str;
+	      json_t *value;
+	      json_object_foreach (json, key_str, value)
+	      {
+		Lisp_Object key
+		  = Fintern (build_string_from_utf8 (key_str), Qnil);
+		result
+		  = Fcons (Fcons (key, json_to_lisp (value, conf)), result);
+	      }
+	      result = Fnreverse (result);
+	      break;
+	    }
+	    case json_object_plist: {
+	      result = Qnil;
+	      const char *key_str;
+	      json_t *value;
+	      json_object_foreach (json, key_str, value)
+	      {
+		USE_SAFE_ALLOCA;
+		ptrdiff_t key_str_len = strlen (key_str);
+		char *keyword_key_str = SAFE_ALLOCA (1 + key_str_len + 1);
+		keyword_key_str[0] = ':';
+		strcpy (&keyword_key_str[1], key_str);
+		Lisp_Object key = intern_1 (keyword_key_str, key_str_len + 1);
+		/* Build the plist as value-key since we're going to
+		   reverse it in the end.*/
+		result = Fcons (key, result);
+		result = Fcons (json_to_lisp (value, conf), result);
+		SAFE_FREE ();
+	      }
+	      result = Fnreverse (result);
+	      break;
+	    }
+	  default:
+	    /* Can't get here.  */
+	    emacs_abort ();
+	  }
+	--lisp_eval_depth;
+	return result;
       }
     }
   /* Can't get here.  */
@@ -973,7 +954,7 @@ to represent a JSON null value.  It defaults to `:null'.
 The keyword argument `:false-object' specifies which object to use to
 represent a JSON false value.  It defaults to `:false'.
 usage: (json-parse-string STRING &rest ARGS) */)
-  (ptrdiff_t nargs, Lisp_Object *args)
+(ptrdiff_t nargs, Lisp_Object *args)
 {
   specpdl_ref count = SPECPDL_INDEX ();
 
@@ -985,8 +966,8 @@ usage: (json-parse-string STRING &rest ARGS) */)
   CHECK_STRING (string);
   Lisp_Object encoded = json_encode (string);
   check_string_without_embedded_nulls (encoded);
-  struct json_configuration conf =
-    {json_object_hashtable, json_array_array, QCnull, QCfalse};
+  struct json_configuration conf
+    = {json_object_hashtable, json_array_array, QCnull, QCfalse};
   json_parse_args (nargs - 1, args + 1, &conf, true);
 
   json_error_t error;
@@ -1009,10 +990,18 @@ usage: (json-parse-string STRING &rest ARGS) */)
 struct json_rpc_state
 {
   pthread_mutex_t handle_mx;
-  struct SSP_Handle* handle;
-  json_t* message;
+  struct SSP_Handle *handle;
+  json_t *message;
   json_error_t error;
   bool done;
+  pid_t pid;
+  // ssp_send could in principle block indefinitely while holding the
+  // handle mutex, so we'll have it use a send timeout to
+  // periodically check for a cancel flag that can be set on shutdown
+  // (done would probably do the job, so the separate flag
+  // cancel_send may later be done away with).  Since this is a
+  // monotonic 1-bit value, I assume no locking is needed (?)
+  bool cancel_send;
   char error_buffer[ERROR_BUFFER_SIZE + 1];
   int error_buffer_read;
 };
@@ -1031,9 +1020,9 @@ end_using_handle (struct json_rpc_state *state)
   pthread_mutex_unlock (&state->handle_mx);
 }
 inline static int
-can_use_handle (struct json_rpc_state *state)
+can_use_handle (struct json_rpc_state *state, struct timespec *timeout)
 {
-  if (pthread_mutex_lock (&state->handle_mx) == 0)
+  if (pthread_mutex_timedlock (&state->handle_mx, timeout) == 0)
     {
       if (state->handle)
 	return 1; /* handle is good */
@@ -1058,11 +1047,10 @@ json_rpc_state_free (void *ptr)
   free (state);
 }
 
-
-DEFUN ("json-rpc-connection", Fjson_rpc_connection, Sjson_rpc_connection, 1, MANY,
-       NULL,
-       doc: /* Create JSONRPC connection. */)
-  (ptrdiff_t nargs, Lisp_Object *args)
+DEFUN ("json-rpc-connection", Fjson_rpc_connection, Sjson_rpc_connection, 1,
+       MANY, NULL, doc
+       : /* Create JSONRPC connection. */)
+(ptrdiff_t nargs, Lisp_Object *args)
 {
   USE_SAFE_ALLOCA;
   char **new_argv;
@@ -1076,11 +1064,11 @@ DEFUN ("json-rpc-connection", Fjson_rpc_connection, Sjson_rpc_connection, 1, MAN
     }
 
   struct SSP_Opts opts;
-  memset(&opts, 0, sizeof(opts));
+  memset (&opts, 0, sizeof (opts));
   opts.binary = new_argv[0];
   opts.argv = new_argv;
   opts.read_timeout_ms = -1;
-  struct SSP_Handle* handle = ssp_spawn(&opts);
+  struct SSP_Handle *handle = ssp_spawn (&opts);
   if (!handle)
     {
       Fsignal (Qerror, list1 (build_string ("Failed to start process.")));
@@ -1092,8 +1080,10 @@ DEFUN ("json-rpc-connection", Fjson_rpc_connection, Sjson_rpc_connection, 1, MAN
       pthread_mutex_init (&state->handle_mx, NULL);
       /* TODO: mutex_init could fail */
       state->handle = handle;
+      state->cancel_send = false;
       state->done = false;
       state->error_buffer_read = 0;
+      state->pid = handle->pid;
       SAFE_FREE ();
       return make_user_ptr (json_rpc_state_free, state);
     }
@@ -1102,18 +1092,24 @@ DEFUN ("json-rpc-connection", Fjson_rpc_connection, Sjson_rpc_connection, 1, MAN
 struct json_rpc_send_params
 {
   struct json_rpc_state *state;
-  json_t* message;
+  json_t *message;
+  // out parameter, will hold the result of send()
+  int res;
 };
 
 static void
-json_rpc_send_callback (void * arg)
+json_rpc_send_callback (void *arg)
 {
   struct json_rpc_send_params *param = arg;
   struct json_rpc_state *state = param->state;
   json_t *message = param->message;
   struct thread_state *self = current_thread;
-
-  if (can_use_handle (state))
+  // TODO: according to @yyoncho, release_global_lock (and, I guess,
+  // sys_thread_yield?) should precede can_use_handle. Haven't looked
+  // into this yet, so for now I'll just leave the order as it was
+  struct timespec timeout = {.tv_sec = 0, .tv_nsec = 5000000};
+  param->res = -1;
+  if (can_use_handle (state, &timeout))
     {
       release_global_lock ();
       sys_thread_yield ();
@@ -1125,7 +1121,13 @@ json_rpc_send_callback (void * arg)
       /* TODO: missing test if msg != NULL */
       sprintf (msg, "Content-Length: %zu\r\n\r\n%s", size, string);
       /* TODO: send could do a partial send */
-      state->handle->send (state->handle, msg, strlen(msg));
+      const int bytes_to_send = strlen (msg);
+      const int bytes_sent
+	= state->handle->send (state->handle, &state->cancel_send, msg,
+			       bytes_to_send);
+      assert (bytes_sent <= bytes_to_send);
+      if (bytes_sent == bytes_to_send)
+	param->res = 0;
       end_using_handle (state);
       free (msg);
       free (string);
@@ -1133,40 +1135,50 @@ json_rpc_send_callback (void * arg)
     }
 }
 
-static struct json_rpc_state * json_rpc_state(Lisp_Object connection) {
+static struct json_rpc_state *
+json_rpc_state (Lisp_Object connection)
+{
   return XUSER_PTR (connection)->p;
 }
 
-DEFUN ("json-rpc-send", Fjson_rpc_send, Sjson_rpc_send, 1, MANY,
-       NULL,
-       doc: /* Send message to jsonrpc connection */)
-  (ptrdiff_t nargs, Lisp_Object *args)
+DEFUN ("json-rpc-send", Fjson_rpc_send, Sjson_rpc_send, 1, MANY, NULL, doc
+       : /* Send message to jsonrpc connection */)
+(ptrdiff_t nargs, Lisp_Object *args)
 {
   Lisp_Object connection = args[0];
-  CHECK_RPC_CONNECTION(connection);
+  CHECK_RPC_CONNECTION (connection);
 
-  struct json_configuration conf =
-    {json_object_hashtable, json_array_array, QCnull, QCfalse};
+  struct json_configuration conf
+    = {json_object_hashtable, json_array_array, QCnull, QCfalse};
   json_parse_args (nargs - 2, args + 2, &conf, false);
 
   json_t *message = lisp_to_json (args[1], &conf);
 
   /* TODO: params is on the stack; is this an issue? */
-  struct json_rpc_send_params params = {
-    .state = json_rpc_state(connection),
-    .message = message
-  };
+  struct json_rpc_send_params params
+    = {.state = json_rpc_state (connection), .message = message, .res = -1};
   flush_stack_call_func (json_rpc_send_callback, &params);
+  if (params.res < 0)
+    {
+      Fsignal (Qerror, list1 (build_string ("Failed to send message")));
+    }
   return Qnil;
 }
 
-DEFUN ("json-rpc-shutdown", Fjson_rpc_shutdown, Sjson_rpc_shutdown, 1, 1, 0,
-       doc: /* Shutdowns json rpc connection */)
-  (Lisp_Object connection)
+DEFUN ("json-rpc-shutdown", Fjson_rpc_shutdown, Sjson_rpc_shutdown, 1, 1, 0, doc
+       : /* Shutdowns json rpc connection */)
+(Lisp_Object connection)
 {
   CHECK_RPC_CONNECTION (connection);
   struct json_rpc_state *state = json_rpc_state (connection);
-  if (can_use_handle (state))
+  // even if send() currently holds the handle mutex, and is executing
+  // a blocking send, setting this to true should cause it to finish
+  // after the send socket's timeout
+  state->cancel_send = true;
+  /* should only block up to sndtimeo in practice, but we'll still specify a
+   * timeout just in case */
+  struct timespec timeout = {.tv_sec = 1, .tv_nsec = 0};
+  if (can_use_handle (state, &timeout))
     {
       state->handle->cancel_recv (state->handle);
       end_using_handle (state);
@@ -1174,47 +1186,26 @@ DEFUN ("json-rpc-shutdown", Fjson_rpc_shutdown, Sjson_rpc_shutdown, 1, 1, 0,
   return Qnil;
 }
 
-DEFUN ("json-rpc-pid", Fjson_rpc_pid, Sjson_rpc_pid, 1, 1, 0,
-       doc: /* Shutdowns json rpc connection */)
-  (Lisp_Object connection)
+DEFUN ("json-rpc-pid", Fjson_rpc_pid, Sjson_rpc_pid, 1, 1, 0, doc
+       : /* Shutdowns json rpc connection */)
+(Lisp_Object connection)
 {
-  int res = 0; /* or -1? */
   CHECK_RPC_CONNECTION (connection);
   struct json_rpc_state *state = json_rpc_state (connection);
-  if (can_use_handle (state))
-    {
-      res = state->handle->pid;
-      end_using_handle (state);
-    }
-  return make_int (res);
+  return make_int (state->done ? -1 : state->pid);
 }
 
-DEFUN ("json-rpc-stderr", Fjson_rpc_stderr, Sjson_rpc_stderr, 1, 1, 0,
-       doc: /* Shutdowns json rpc connection */)
-  (Lisp_Object connection)
+DEFUN ("json-rpc-stderr", Fjson_rpc_stderr, Sjson_rpc_stderr, 1, 1, 0, doc
+       : /* Shutdowns json rpc connection */)
+(Lisp_Object connection)
 {
-  CHECK_RPC_CONNECTION(connection);
-  struct json_rpc_state* state = json_rpc_state(connection);
-  return make_string(state->error_buffer, state->error_buffer_read);
-}
-
-DEFUN ("json-rpc-alive-p", Fjson_rpc_alive_p, Sjson_rpc_alive_p, 1, 1, 0,
-       doc: /* Returns if json rpc connection is alive */)
-  (Lisp_Object connection)
-{
-  int res = 0; /* is not, by default */
-  CHECK_RPC_CONNECTION(connection);
+  CHECK_RPC_CONNECTION (connection);
   struct json_rpc_state *state = json_rpc_state (connection);
-  if (can_use_handle (state))
-    {
-      res = state->handle->isalive (state->handle);
-      end_using_handle (state);
-    }
-  return res ? Qt : Qnil;
+  return make_string (state->error_buffer, state->error_buffer_read);
 }
 
-static size_t read_stdout (struct json_rpc_state *param, char *buffer,
-			   size_t size)
+static size_t
+read_stdout (struct json_rpc_state *param, char *buffer, size_t size)
 {
   struct SSP_Handle *handle = param->handle;
   size_t result, read_res;
@@ -1223,16 +1214,18 @@ static size_t read_stdout (struct json_rpc_state *param, char *buffer,
       result = size;
       size_t stderr_size = ERROR_BUFFER_SIZE - param->error_buffer_read;
       read_res = handle->recv (handle, buffer, &result,
-			  param->error_buffer + param->error_buffer_read,
-			  &stderr_size);
+			       param->error_buffer + param->error_buffer_read,
+			       &stderr_size);
 
       if (stderr_size)
 	{
 	  param->error_buffer_read += stderr_size;
-	  if (param->error_buffer_read == ERROR_BUFFER_SIZE) {
-	    param->error_buffer_read = ERROR_BUFFER_SIZE / 2;
-	    strcpy(param->error_buffer, param->error_buffer + ERROR_BUFFER_SIZE / 2);
-	  }
+	  if (param->error_buffer_read == ERROR_BUFFER_SIZE)
+	    {
+	      param->error_buffer_read = ERROR_BUFFER_SIZE / 2;
+	      strcpy (param->error_buffer,
+		      param->error_buffer + ERROR_BUFFER_SIZE / 2);
+	    }
 	}
 
       if (result)
@@ -1242,8 +1235,8 @@ static size_t read_stdout (struct json_rpc_state *param, char *buffer,
   return result;
 }
 
-static bool read_until (struct json_rpc_state *param, const char *needle,
-			char *output)
+static bool
+read_until (struct json_rpc_state *param, const char *needle, char *output)
 {
   // XXX: optimize the first read and make sure output is not
   // overflowing
@@ -1297,7 +1290,9 @@ json_rpc_callback (void *arg)
 	  if (!param->done)
 	    {
 	      msg[content_length] = '\0';
-	      param->message = json_loads (msg, JSON_DECODE_ANY | JSON_ALLOW_NUL, &param->error);
+	      param->message
+		= json_loads (msg, JSON_DECODE_ANY | JSON_ALLOW_NUL,
+			      &param->error);
 	      free (msg);
 	    }
 	}
@@ -1346,25 +1341,24 @@ get_json_parse_error (const json_error_t *error)
 			       INT_TO_INTEGER (error->position)));
 }
 
-DEFUN ("json-rpc", Fjson_rpc, Sjson_rpc, 1, MANY,
-       NULL,
-       doc: /* Runs json-rpc dispach loop over jsonrpc connection */)
-  (ptrdiff_t nargs, Lisp_Object *args)
+DEFUN ("json-rpc", Fjson_rpc, Sjson_rpc, 1, MANY, NULL, doc
+       : /* Runs json-rpc dispach loop over jsonrpc connection */)
+(ptrdiff_t nargs, Lisp_Object *args)
 {
   Lisp_Object connection = args[0];
-  CHECK_RPC_CONNECTION(connection);
+  CHECK_RPC_CONNECTION (connection);
 
   Lisp_Object callback = args[1];
 
-  struct json_configuration conf =
-    {json_object_hashtable, json_array_array, QCnull, QCfalse};
+  struct json_configuration conf
+    = {json_object_hashtable, json_array_array, QCnull, QCfalse};
 
   json_parse_args (nargs - 2, args + 2, &conf, true);
 
-  struct json_rpc_state* param = json_rpc_state(connection);
-  struct SSP_Handle* handle = param->handle;
+  struct json_rpc_state *param = json_rpc_state (connection);
+  struct SSP_Handle *handle = param->handle;
 
-  while (!param->done && handle->isalive(handle))
+  while (!param->done && handle->isalive (handle))
     {
       flush_stack_call_func (json_rpc_callback, param);
 
@@ -1374,16 +1368,19 @@ DEFUN ("json-rpc", Fjson_rpc, Sjson_rpc, 1, MANY,
 	    {
 	      Lisp_Object msg = json_to_lisp (param->message, &conf);
 	      free (param->message);
-              param->message = NULL;
+	      param->message = NULL;
 	      CALLN (Ffuncall, callback, msg, Qnil, Qnil);
 	    }
 	  else
 	    {
-	      Lisp_Object error = get_json_parse_error(&param->error);
+	      Lisp_Object error = get_json_parse_error (&param->error);
 	      CALLN (Ffuncall, callback, Qnil, error, Qnil);
 	    }
-	} else {
-      }
+	}
+      else
+	{
+	  // ??
+	}
     }
   CALLN (Ffuncall, callback, Qnil, Qnil, Qt);
   if (pthread_mutex_lock (&param->handle_mx) == 0)
@@ -1457,7 +1454,7 @@ to represent a JSON null value.  It defaults to `:null'.
 The keyword argument `:false-object' specifies which object to use to
 represent a JSON false value.  It defaults to `:false'.
 usage: (json-parse-buffer &rest args) */)
-     (ptrdiff_t nargs, Lisp_Object *args)
+(ptrdiff_t nargs, Lisp_Object *args)
 {
   specpdl_ref count = SPECPDL_INDEX ();
 
@@ -1465,19 +1462,17 @@ usage: (json-parse-buffer &rest args) */)
   ensure_json_available ();
 #endif
 
-  struct json_configuration conf =
-    {json_object_hashtable, json_array_array, QCnull, QCfalse};
+  struct json_configuration conf
+    = {json_object_hashtable, json_array_array, QCnull, QCfalse};
   json_parse_args (nargs, args, &conf, true);
 
   ptrdiff_t point = PT_BYTE;
   struct json_read_buffer_data data = {.point = point};
   json_error_t error;
-  json_t *object
-    = json_load_callback (json_read_buffer_callback, &data,
-                          JSON_DECODE_ANY
-			  | JSON_DISABLE_EOF_CHECK
-			  | JSON_ALLOW_NUL,
-                          &error);
+  json_t *object = json_load_callback (json_read_buffer_callback, &data,
+				       JSON_DECODE_ANY | JSON_DISABLE_EOF_CHECK
+					 | JSON_ALLOW_NUL,
+				       &error);
 
   if (object == NULL)
     json_parse_error (&error);
@@ -1513,14 +1508,13 @@ syms_of_json (void)
   DEFSYM (Qjson_unavailable, "json-unavailable");
   define_error (Qjson_error, "generic JSON error", Qerror);
   define_error (Qjson_out_of_memory,
-                "not enough memory for creating JSON object", Qjson_error);
-  define_error (Qjson_parse_error, "could not parse JSON stream",
-                Qjson_error);
+		"not enough memory for creating JSON object", Qjson_error);
+  define_error (Qjson_parse_error, "could not parse JSON stream", Qjson_error);
   define_error (Qjson_end_of_file, "end of JSON stream", Qjson_parse_error);
   define_error (Qjson_trailing_content, "trailing content after JSON stream",
-                Qjson_parse_error);
+		Qjson_parse_error);
   define_error (Qjson_object_too_deep,
-                "object cyclic or Lisp evaluation too deep", Qjson_error);
+		"object cyclic or Lisp evaluation too deep", Qjson_error);
 
   DEFSYM (Qpure, "pure");
   DEFSYM (Qside_effect_free, "side-effect-free");
@@ -1531,7 +1525,6 @@ syms_of_json (void)
   DEFSYM (Qjson_rpc_connection, "json-rpc-connection");
   DEFSYM (Qjson_rpc_shutdown, "json-rpc-shutdown");
   DEFSYM (Qjson_rpc_send, "json-rpc-send");
-  DEFSYM (Qjson_rpc_alive_p, "json-rpc-alive-p");
   DEFSYM (Qjson_rpc_pid, "json-rpc-pid");
   DEFSYM (Qjson_rpc_close, "json-rpc-close");
   DEFSYM (Qjson_rpc_stderr, "json-rpc-stderr");
@@ -1558,6 +1551,5 @@ syms_of_json (void)
   defsubr (&Sjson_rpc_shutdown);
   defsubr (&Sjson_rpc_pid);
   defsubr (&Sjson_rpc_stderr);
-  defsubr (&Sjson_rpc_alive_p);
   defsubr (&Sjson_parse_buffer);
 }
diff --git a/src/spsupr.c b/src/spsupr.c
index 864c60975fd..d19d58b0fe3 100644
--- a/src/spsupr.c
+++ b/src/spsupr.c
@@ -13,206 +13,257 @@
 #include <sysexits.h>
 #include <unistd.h>
 
-enum { parent_end = 0, child_end = 1 };
-
-struct SSP_Posix {
-	struct SSP_Handle handle;
-	struct pollfd fds[3];
-	pid_t pid;
-	int io_fd; /* two-way: sub-process' stdin and stdout */
-	int err_fd; /* to read sub-process' stderr */
-	/* Sending a byte at write end will unblock a waiting recv() */
-	int cancelwr_fd, cancelrd_fd;
-	int timeout_ms; /* 0 for poll, -1 for wait forever */
-	int isalive;
+enum
+{
+  parent_end = 0,
+  child_end = 1
 };
-#define GETH(_h) \
-	((struct SSP_Posix *)((char *)_h - offsetof(struct SSP_Posix, handle)))
+
+struct SSP_Posix
+{
+  struct SSP_Handle handle;
+  struct pollfd fds[3];
+  pid_t pid;
+  int io_fd;  /* two-way: sub-process' stdin and stdout */
+  int err_fd; /* to read sub-process' stderr */
+  /* Sending a byte at write end will unblock a waiting recv() */
+  int cancelwr_fd, cancelrd_fd;
+  int timeout_ms; /* 0 for poll, -1 for wait forever */
+  int isalive;
+};
+#define GETH(_h)                                                               \
+  ((struct SSP_Posix *) ((char *) _h - offsetof (struct SSP_Posix, handle)))
 
 static int
-ssp_send(struct SSP_Handle *ssph, void *buf, size_t sz)
+ssp_send (struct SSP_Handle *ssph, _Bool *cancel_flag, void *buf, size_t sz)
 {
-	struct SSP_Posix *h = GETH(ssph);
-	ssize_t res;
-	do
-		res = send(h->io_fd, buf, sz, MSG_NOSIGNAL);
-	while (res == -1 && errno == EINTR);
-	return (int)res;
+  struct SSP_Posix *h = GETH (ssph);
+  ssize_t bytes_sent = 0;
+  do
+    {
+      const ssize_t res = send (h->io_fd, buf, sz, MSG_NOSIGNAL);
+      if (res >= 0)
+	{
+	  bytes_sent += res;
+	}
+      else
+	{
+	  switch (errno)
+	    {
+	    case EINTR: /* interrupted: keep going */
+	    case EAGAIN:
+	      /* timed out: keep going, unless we're told to abort */
+	      if (*cancel_flag)
+		return res;
+	      break;
+	    default:
+	      // some other error: always return error code
+	      return res;
+	    }
+	}
+  } while (bytes_sent < sz && !*cancel_flag);
+  assert (bytes_sent == sz);
+  return (int) bytes_sent;
 }
 
 static int
-ssp_recv(struct SSP_Handle *ssph, void *stdout_buf, size_t *stdout_buf_sz,
-	 void *stderr_buf, size_t *stderr_buf_sz)
+ssp_recv (struct SSP_Handle *ssph, void *stdout_buf, size_t *stdout_buf_sz,
+	  void *stderr_buf, size_t *stderr_buf_sz)
 {
-	struct SSP_Posix *h = GETH(ssph);
-	const size_t sz1 = *stdout_buf_sz, sz2 = *stderr_buf_sz;
-	int ready, have_data, have_err = 0;
-	ssize_t len;
-
-	*stdout_buf_sz = *stderr_buf_sz = 0;
-	do
-		ready = poll(h->fds, 3, h->timeout_ms);
-	while (ready == -1 && errno == EINTR);
-	if (!ready)
-		return 0;
-
-	if (ready && (h->fds[0].revents & POLLIN) == POLLIN) {
-		do
-			len = recv(h->io_fd, stdout_buf, sz1, MSG_DONTWAIT);
-		while (len == -1 && errno == EINTR);
-		if (len > 0) {
-			*stdout_buf_sz = (size_t)len;
-		} else if (!len) {
-			h->isalive = 0;
-		} else {
-			have_err = 1;
-		}
-		--ready;
+  struct SSP_Posix *h = GETH (ssph);
+  const size_t sz1 = *stdout_buf_sz, sz2 = *stderr_buf_sz;
+  int ready, have_data, have_err = 0;
+  ssize_t len;
+
+  *stdout_buf_sz = *stderr_buf_sz = 0;
+  do
+    ready = poll (h->fds, 3, h->timeout_ms);
+  while (ready == -1 && errno == EINTR);
+  if (!ready)
+    return 0;
+
+  if (ready && (h->fds[0].revents & POLLIN) == POLLIN)
+    {
+      do
+	len = recv (h->io_fd, stdout_buf, sz1, MSG_DONTWAIT);
+      while (len == -1 && errno == EINTR);
+      if (len > 0)
+	{
+	  *stdout_buf_sz = (size_t) len;
+	}
+      else if (!len)
+	{
+	  h->isalive = 0;
 	}
-	if (ready && (h->fds[1].revents & POLLIN) == POLLIN) {
-		do
-			len = recv(h->err_fd, stderr_buf, sz2, MSG_DONTWAIT);
-		while (len == -1 && errno == EINTR);
-		if (len > 0) {
-			*stderr_buf_sz = (size_t)len;
-		} else if (!len) {
-			h->isalive = 0;
-		} else {
-			have_err = 1;
-		}
-		--ready;
+      else
+	{
+	  have_err = 1;
 	}
-	if (ready && (h->fds[2].revents & POLLIN) == POLLIN) {
-		char buf[20];
-		do
-			len = recv(h->cancelrd_fd, buf, sizeof(buf),
-				   MSG_DONTWAIT);
-		while (len == -1 && errno == EINTR);
-		--ready;
+      --ready;
+    }
+  if (ready && (h->fds[1].revents & POLLIN) == POLLIN)
+    {
+      do
+	len = recv (h->err_fd, stderr_buf, sz2, MSG_DONTWAIT);
+      while (len == -1 && errno == EINTR);
+      if (len > 0)
+	{
+	  *stderr_buf_sz = (size_t) len;
 	}
-	have_data = *stdout_buf_sz || *stderr_buf_sz;
-	return have_data ? 1 : have_err ? -1 : 0;
+      else if (!len)
+	{
+	  h->isalive = 0;
+	}
+      else
+	{
+	  have_err = 1;
+	}
+      --ready;
+    }
+  if (ready && (h->fds[2].revents & POLLIN) == POLLIN)
+    {
+      char buf[20];
+      do
+	len = recv (h->cancelrd_fd, buf, sizeof (buf), MSG_DONTWAIT);
+      while (len == -1 && errno == EINTR);
+      --ready;
+    }
+  have_data = *stdout_buf_sz || *stderr_buf_sz;
+  return have_data ? 1 : have_err ? -1 : 0;
 }
 
 static void
-ssp_cancel_recv(struct SSP_Handle *ssph)
+ssp_cancel_recv (struct SSP_Handle *ssph)
 {
-	struct SSP_Posix *h = GETH(ssph);
-	send(h->cancelwr_fd, h, 1, 0);
+  struct SSP_Posix *h = GETH (ssph);
+  send (h->cancelwr_fd, h, 1, 0);
 }
 
 static int
-ssp_isalive(struct SSP_Handle *ssph)
+ssp_isalive (struct SSP_Handle *ssph)
 {
-	struct SSP_Posix *h = GETH(ssph);
-	return h->isalive;
+  struct SSP_Posix *h = GETH (ssph);
+  return h->isalive;
 }
 
 static void
-ssp_close(struct SSP_Handle *ssph)
+ssp_close (struct SSP_Handle *ssph)
 {
-	struct SSP_Posix *h = GETH(ssph);
-	int status;
-	close(h->cancelrd_fd);
-	close(h->cancelwr_fd);
-	close(h->err_fd);
-	close(h->io_fd);
-	(void)waitpid(h->pid, &status, WNOHANG);
-	free(h);
+  struct SSP_Posix *h = GETH (ssph);
+  int status;
+  close (h->cancelrd_fd);
+  close (h->cancelwr_fd);
+  close (h->err_fd);
+  close (h->io_fd);
+  (void) waitpid (h->pid, &status, WNOHANG);
+  free (h);
 }
 
 struct SSP_Handle *
-ssp_spawn(struct SSP_Opts *opts)
+ssp_spawn (struct SSP_Opts *opts)
 {
-	int io_fds[2] = { -1, -1 }; /* two-way: stdin & stdout */
-	int err_fds[2] = { -1, -1 }; /* stderr, read-only */
-	int unbl_fds[2] = { -1, -1 };
-	int eno;
-	pid_t pid = -1;
-	struct SSP_Posix *res = NULL;
-
-	assert(opts);
-	assert(opts->binary);
-
-	res = (struct SSP_Posix *)calloc(1, sizeof(*res));
-	if (!res)
-		return NULL;
-
-	if (socketpair(AF_LOCAL, SOCK_STREAM, 0, io_fds) == -1 ||
-	    socketpair(AF_LOCAL, SOCK_STREAM, 0, err_fds) == -1 ||
-	    socketpair(AF_LOCAL, SOCK_STREAM, 0, unbl_fds) == -1)
-		goto abort;
-	pid = fork();
-	if (pid == 0) {
-		/* Child: */
-		char *const *it;
-		close(io_fds[parent_end]);
-		close(err_fds[parent_end]);
-		close(unbl_fds[1]);
-		close(unbl_fds[0]);
-		if (dup2(io_fds[child_end], STDIN_FILENO) == -1 ||
-		    dup2(io_fds[child_end], STDOUT_FILENO) == -1 ||
-		    dup2(err_fds[child_end], STDERR_FILENO) == -1)
-			err(EX_OSERR, "dup2");
-
-		if (opts->envp)
-			for (it = opts->envp; *it; ++it)
-				putenv(*it);
-
-		if (opts->binary[0] == '/' || opts->binary[0] == '.') {
-			/* Assume path is included */
-			execv(opts->binary, opts->argv);
-		} else {
-			execvp(opts->binary, opts->argv);
-		}
-		err(EX_OSERR, "cannot execute '%s'", opts->binary);
-		exit(EX_OSERR);
-
-	} else if (pid != -1) {
-		close(io_fds[child_end]);
-		close(err_fds[child_end]);
-		res->handle.send = &ssp_send;
-		res->handle.recv = &ssp_recv;
-		res->handle.cancel_recv = &ssp_cancel_recv;
-		res->handle.isalive = &ssp_isalive;
-		res->handle.close = &ssp_close;
-		res->handle.pid = pid;
-		res->fds[0].fd = io_fds[parent_end];
-		res->fds[0].events = POLLIN;
-		res->fds[1].fd = err_fds[parent_end];
-		res->fds[1].events = POLLIN;
-		res->fds[2].fd = unbl_fds[parent_end];
-		res->fds[2].events = POLLIN;
-		res->pid = pid;
-		res->io_fd = io_fds[parent_end];
-		res->err_fd = err_fds[parent_end];
-		res->cancelwr_fd = unbl_fds[child_end];
-		res->cancelrd_fd = unbl_fds[parent_end];
-		res->timeout_ms = opts->read_timeout_ms;
-		res->isalive = 1;
-		return &res->handle;
-
-	} else {
-		goto abort;
+  int io_fds[2] = {-1, -1};  /* two-way: stdin & stdout */
+  int err_fds[2] = {-1, -1}; /* stderr, read-only */
+  int unbl_fds[2] = {-1, -1};
+  int eno;
+  pid_t pid = -1;
+  struct SSP_Posix *res = NULL;
+
+  assert (opts);
+  assert (opts->binary);
+
+  res = (struct SSP_Posix *) calloc (1, sizeof (*res));
+  if (!res)
+    return NULL;
+
+  if (socketpair (AF_LOCAL, SOCK_STREAM, 0, io_fds) == -1
+      || socketpair (AF_LOCAL, SOCK_STREAM, 0, err_fds) == -1
+      || socketpair (AF_LOCAL, SOCK_STREAM, 0, unbl_fds) == -1)
+    goto abort;
+  pid = fork ();
+  if (pid == 0)
+    {
+      /* Child: */
+      char *const *it;
+      close (io_fds[parent_end]);
+      close (err_fds[parent_end]);
+      close (unbl_fds[1]);
+      close (unbl_fds[0]);
+      if (dup2 (io_fds[child_end], STDIN_FILENO) == -1
+	  || dup2 (io_fds[child_end], STDOUT_FILENO) == -1
+	  || dup2 (err_fds[child_end], STDERR_FILENO) == -1)
+	err (EX_OSERR, "dup2");
+
+      if (opts->envp)
+	for (it = opts->envp; *it; ++it)
+	  putenv (*it);
+
+      if (opts->binary[0] == '/' || opts->binary[0] == '.')
+	{
+	  /* Assume path is included */
+	  execv (opts->binary, opts->argv);
+	}
+      else
+	{
+	  execvp (opts->binary, opts->argv);
+	}
+      err (EX_OSERR, "cannot execute '%s'", opts->binary);
+      exit (EX_OSERR);
+    }
+  else if (pid != -1)
+    {
+      close (io_fds[child_end]);
+      close (err_fds[child_end]);
+      res->handle.send = &ssp_send;
+      res->handle.recv = &ssp_recv;
+      res->handle.cancel_recv = &ssp_cancel_recv;
+      res->handle.isalive = &ssp_isalive;
+      res->handle.close = &ssp_close;
+      res->handle.pid = pid;
+      res->fds[0].fd = io_fds[parent_end];
+      res->fds[0].events = POLLIN;
+      res->fds[1].fd = err_fds[parent_end];
+      res->fds[1].events = POLLIN;
+      res->fds[2].fd = unbl_fds[parent_end];
+      res->fds[2].events = POLLIN;
+      res->pid = pid;
+      res->io_fd = io_fds[parent_end];
+      res->err_fd = err_fds[parent_end];
+      res->cancelwr_fd = unbl_fds[child_end];
+      res->cancelrd_fd = unbl_fds[parent_end];
+      res->timeout_ms = opts->read_timeout_ms;
+      res->isalive = 1;
+      struct timeval send_timeout = {.tv_sec = 0, .tv_usec = 10000000};
+      if (setsockopt (io_fds[parent_end], SOL_SOCKET, SO_SNDTIMEO,
+		      &send_timeout, sizeof (send_timeout))
+	  != 0)
+	{
+	  // TODO: fail?
 	}
+      return &res->handle;
+    }
+  else
+    {
+      goto abort;
+    }
 abort:
-	eno = errno;
-	if (unbl_fds[1] != -1)
-		close(unbl_fds[1]);
-	if (unbl_fds[0] != -1)
-		close(unbl_fds[0]);
-	if (err_fds[1] != -1)
-		close(err_fds[1]);
-	if (err_fds[0] != -1)
-		close(err_fds[0]);
-	if (io_fds[1] != -1)
-		close(io_fds[1]);
-	if (io_fds[0] != -1)
-		close(io_fds[0]);
-	if (res)
-		free(res);
-	errno = eno;
-	return NULL;
+  eno = errno;
+  if (unbl_fds[1] != -1)
+    close (unbl_fds[1]);
+  if (unbl_fds[0] != -1)
+    close (unbl_fds[0]);
+  if (err_fds[1] != -1)
+    close (err_fds[1]);
+  if (err_fds[0] != -1)
+    close (err_fds[0]);
+  if (io_fds[1] != -1)
+    close (io_fds[1]);
+  if (io_fds[0] != -1)
+    close (io_fds[0]);
+  if (res)
+    free (res);
+  errno = eno;
+  return NULL;
 }
 
 #else
diff --git a/src/spsupr.h b/src/spsupr.h
index 0babf18c7d2..c9cb63a2d2a 100644
--- a/src/spsupr.h
+++ b/src/spsupr.h
@@ -1,10 +1,13 @@
 #pragma once
 
 #include <stdlib.h>
+#include <stdbool.h>
 
-struct SSP_Handle {
+struct SSP_Handle
+{
   /* Returns # of bytes sent or -1 on error */
-  int (*send) (struct SSP_Handle *ssph, void *buf, size_t sz);
+  int (*send) (struct SSP_Handle *ssph, _Bool *cancel_flag, void *buf,
+	       size_t sz);
   /* Returns 0 if no data, 1 if data received and updates ..._buf_sz,
    * -1 on error */
   int (*recv) (struct SSP_Handle *ssph, void *stdout_buf, size_t *stdout_buf_sz,
@@ -17,12 +20,14 @@ struct SSP_Handle {
   int pid;
 };
 
-struct SSP_Opts {
-	const char *binary;
-	char *const *argv; /* NULL-terminated */
-	char *const *envp; /* NULL-terminated */
-	/* 0 for polling, -1 for wait forever */
-	int read_timeout_ms;
+struct SSP_Opts
+{
+  const char *binary;
+  char *const *argv; /* NULL-terminated */
+  char *const *envp; /* NULL-terminated */
+  /* 0 for polling, -1 for wait forever */
+  int read_timeout_ms;
 };
 
-struct SSP_Handle *ssp_spawn(struct SSP_Opts *opts);
+struct SSP_Handle *
+ssp_spawn (struct SSP_Opts *opts);
-- 
2.42.0

