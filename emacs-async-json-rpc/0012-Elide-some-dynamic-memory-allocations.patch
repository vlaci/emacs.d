From 375932ecd5f7ad5cdc7af64894d230a118731944 Mon Sep 17 00:00:00 2001
From: Sebastian Sturm <s.sturm@arkona-technologies.de>
Date: Sun, 26 Feb 2023 22:44:34 +0100
Subject: [PATCH 12/13] Elide some dynamic memory allocations

if libjansson v2.10+ is available
---
 src/json.c | 63 +++++++++++++++++++++++++++++++++++++++++++-----------
 1 file changed, 51 insertions(+), 12 deletions(-)

diff --git a/src/json.c b/src/json.c
index 186d970f6ab..86b7346ce17 100644
--- a/src/json.c
+++ b/src/json.c
@@ -39,6 +39,7 @@ along with GNU Emacs.  If not, see <https://www.gnu.org/licenses/>.  */
 #include "spsupr.c"
 
 #define JSON_HAS_ERROR_CODE (JANSSON_VERSION_HEX >= 0x020B00)
+#define JSON_HAS_DUMPB (JANSSON_VERSION_HEX >= 0x020A00)
 
 const int BUFFER_SIZE = 1000;
 
@@ -987,6 +988,7 @@ usage: (json-parse-string STRING &rest ARGS) */)
 // JSONRPC
 
 #define ERROR_BUFFER_SIZE 1024 * 1024 * 4
+#define DUMP_BUFFER_SIZE (1 << 16)
 
 struct json_rpc_state
 {
@@ -1003,8 +1005,14 @@ struct json_rpc_state
   // cancel_send may later be done away with).  Since this is a
   // monotonic 1-bit value, I assume no locking is needed (?)
   bool cancel_send;
-  char error_buffer[ERROR_BUFFER_SIZE + 1];
+  // if supported by libjansson (v2.10+), we'll use json_dumpb to
+  // serialize json messages straight into a preexisting buffer, hence
+  // saving some intermediate allocations
   int error_buffer_read;
+  char error_buffer[ERROR_BUFFER_SIZE + 1];
+#if JSON_HAS_DUMPB
+  char dump_buffer[DUMP_BUFFER_SIZE];
+#endif
 };
 
 /* Usage:
@@ -1116,23 +1124,54 @@ json_rpc_send_callback (void *arg)
   sys_thread_yield ();
   if (can_use_handle (state, &timeout))
     {
-      char *string = json_dumps (message, JSON_COMPACT | JSON_ENCODE_ANY);
-      /* TODO: no point in copying whole message */
-      size_t size = strlen (string);
-      char *msg = malloc (size + 100);
-      /* TODO: missing test if msg != NULL */
-      sprintf (msg, "Content-Length: %zu\r\n\r\n%s", size, string);
-      /* TODO: send could do a partial send */
-      const int bytes_to_send = strlen (msg);
+      char *string = NULL;
+      char *msg = NULL;
+      _Bool use_malloc = true;
+      int bytes_to_send = -1;
+#if JSON_HAS_DUMPB
+      // most messages will fit into our dump buffer, and thus
+      // can be serialized without additional dynamic memory allocations
+      const int header_offset
+	= sprintf (state->dump_buffer, "Content-Length: % 30d\r\n\r\n", 0);
+      const int bytes_left = DUMP_BUFFER_SIZE - 1 - header_offset;
+      bytes_to_send = json_dumpb (message, state->dump_buffer + header_offset,
+				  bytes_left, JSON_COMPACT | JSON_ENCODE_ANY);
+      if (bytes_to_send > 0 && bytes_to_send <= bytes_left)
+	{
+	  use_malloc = false;
+	  state->dump_buffer[header_offset + bytes_to_send] = '\0';
+	  /* ugly: overwrite header template with actual message length */
+	  const char c = state->dump_buffer[header_offset];
+	  sprintf (state->dump_buffer, "Content-Length: % 30d\r\n\r\n",
+		   bytes_to_send);
+	  bytes_to_send += header_offset;
+	  state->dump_buffer[header_offset] = c;
+	  msg = state->dump_buffer;
+	}
+#endif
+      if (use_malloc)
+	{
+	  string = json_dumps (message, JSON_COMPACT | JSON_ENCODE_ANY);
+	  /* TODO: no point in copying whole message */
+	  size_t size = strlen (string);
+	  msg = malloc (size + 100);
+	  /* TODO: missing test if msg != NULL */
+	  sprintf (msg, "Content-Length: %zu\r\n\r\n%s", size, string);
+	  bytes_to_send = strlen (msg);
+	}
+      assert (!!msg);
       const int bytes_sent
 	= state->handle->send (state->handle, &state->cancel_send, msg,
-			       bytes_to_send);
+			       (size_t) bytes_to_send);
       assert (bytes_sent <= bytes_to_send);
       if (bytes_sent == bytes_to_send)
 	param->res = 0;
       end_using_handle (state);
-      free (msg);
-      free (string);
+      if (use_malloc)
+	{
+	  free (msg);
+	  free (string);
+	}
     }
   acquire_global_lock (self);
 }
-- 
2.42.0

