#+TITLE: vlaci's Emacs configuration

This repository is written using literate programming. All code necessary to develop it and run Emacs is generated from this =README=.

* How-to

This repository uses [[https://github.com/direnv/direnv][direnv]] together with [[https://github.com/target/lorri][lorri]] to automatically create a development shell. It is an optional tool, just using =nix develop= works as well. To help running common development tasks, the following [[https://github.com/casey/just][just]] is needed.

You can see what commands are available with their short description by running =just help=:
#+begin_src sh :tangle no :results output :wrap example :exports results
  just help
#+end_src

#+RESULTS:
#+begin_example
Available recipes:
    help   # Print help
    try
    tangle
#+end_example

** Under the hoods
To set-up =lorri=, we define this =.envrc=:

#+begin_src sh :tangle .envrc
  if type lorri &>/dev/null; then
      echo "direnv: using lorri"
      eval "$(lorri direnv)"
      IN_LORRI_SHELL= eval "$shellHook"
  else
      # fall back to using direnv's builtin nix support
      # to prevent bootstrapping problems.
      use nix
  fi
#+end_src

You need to tell =direnv= to trust this this code:

#+begin_src sh :tangle no
  direnv allow
#+end_src

Now everything is set-up to be able to run the following =justfile=

#+begin_src makefile :tangle justfile
  # Print help
  help:
      just --list --unsorted

  try:
      #!/bin/sh -e
      OUT=$(mktemp -u --suffix .result)
      echo "Building into $OUT..."
      trap "rm -f $OUT" EXIT
      NIXPKGS_ALLOW_UNFREE=1 nix build --impure --out-link $OUT
      $OUT/bin/emacs --debug-init

  tangle:
      #!/usr/bin/env nix-shell
      #!nix-shell -p emacs -i "emacs --script"
      (require 'ob-tangle)
      (org-babel-tangle-file "README.org" nil "makefile\\|sh")
#+end_src

* early-init
:PROPERTIES:
:header-args: :tangle early-init.el
:END:
Early init is loaded before graphics subsystem is initialized so it makes sense
to disable UI elements from it. Lifted from ~doom-emacs~
#+begin_src emacs-lisp
  ;;; early-init.el -*- lexical-binding: t; -*-

  ;; Defer garbage collection further back in the startup process
  (setq gc-cons-threshold most-positive-fixnum)

  ;; In Emacs 27+, package initialization occurs before `user-init-file' is
  ;; loaded, but after `early-init-file'. Doom handles package initialization, so
  ;; we must prevent Emacs from doing it early!
  (setq package-enable-at-startup nil)

  ;; Prevent the glimpse of un-styled Emacs by disabling these UI elements early.
  (push '(menu-bar-lines . 0) default-frame-alist)
  (push '(tool-bar-lines . 0) default-frame-alist)
  (push '(vertical-scroll-bars) default-frame-alist)

  ;; Resizing the Emacs frame can be a terribly expensive part of changing the
  ;; font. By inhibiting this, we easily halve startup times with fonts that are
  ;; larger than the system default.
  (setq frame-inhibit-implied-resize t
        idle-update-delay 1.0
        inhibit-compacting-font-caches t
        fast-but-imprecise-scrolling t
        redisplay-skip-fontification-on-input t
        initial-major-mode 'fundamental-mode)

  (setq use-dialog-box nil)

  (setq inhibit-startup-message t
        inhibit-startup-echo-area-message user-login-name
        inhibit-default-init t
        inhibit-startup-sceen t
        initial-scratch-message nil)
  (setq auto-mode-case-fold nil
        read-process-output-max (* 64 1024 1024))

  (unless (or (daemonp) noninteractive)
    (let ((old-file-name-handler-alist file-name-handler-alist))
      ;; `file-name-handler-alist' is consulted on each `require', `load' and
      ;; various path/io functions. You get a minor speed up by unsetting this.
      ;; Some warning, however: this could cause problems on builds of Emacs where
      ;; its site lisp files aren't byte-compiled and we're forced to load the
      ;; *.el.gz files (e.g. on Alpine).
      (setq-default file-name-handler-alist nil)
      ;; ...but restore `file-name-handler-alist' later, because it is needed for
      ;; handling encrypted or compressed files, among other things.
      (defun vl-reset-file-handler-alist ()
        (setq file-name-handler-alist
              ;; Merge instead of overwrite because there may have bene changes to
              ;; `file-name-handler-alist' since startup we want to preserve.
              (delete-dups (append file-name-handler-alist
                                   old-file-name-handler-alist))))
      (add-hook 'emacs-startup-hook #'vl-reset-file-handler-alist 101)))

#+end_src

* init.el
:PROPERTIES:
:header-args: :tangle init.el
:END:
** initialization
#+begin_src emacs-lisp
  ;;; init.el -*- lexical-binding: t; -*-
  (setq vc-follow-symlinks nil)

  (defun vl-display-startup-time ()
    (message "‚è± Emacs started in %s seconds with %d garbage collections."
             (emacs-init-time)
             gcs-done))
  (add-hook 'emacs-startup-hook #'vl-display-startup-time)
#+end_src
*** use-package

#+begin_src emacs-lisp
  (eval-and-compile
    (require 'bind-key)
    (require 'use-package))
  (setq use-package-always-defer nil
        use-package-verbose nil
        use-package-compute-statistics nil
        use-package-expand-minimally t)
  (package-activate-all)
#+end_src

**** Extensions
The following code is ported from =doom-emacs=
#+begin_src emacs-lisp
  (defvar vl-incremental-packages '(t))
  (defvar vl-incremental-idle-timer 0.75)
  (defvar vl-incremental-first-idle-timer 2.0)
  (defvar vl-incremental-load-immediately (daemonp))

  (defvar vl--deferred-packages-alist '(t))

  (defun vl-load-packages-incrementally (packages &optional now)
    "Registers PACKAGES to be loaded incrementally.

  If NOW is non-nil, load PACKAGES incrementally, in `vl-incremental-idle-timer'
  intervals."
    (if (not now)
        (setq vl-incremental-packages (append vl-incremental-packages packages))
      (while packages
        (let* ((gc-cons-threshold most-positive-fixnum)
               (req (pop packages)))
          (unless (featurep req)
            (message "Incrementally loading %s" req)
            (condition-case-unless-debug e
                (or (while-no-input
                      (let ((inhibit-message t)
                            file-name-handler-alist)
                        (require req nil t))
                      t)
                    (push req packages))
              (error
               (message "Failed to load %S package incrementally, because: %s"
                        req e)))
            (if (not packages)
                (message "Finished incremental loading")
              (run-with-idle-timer vl-incremental-idle-timer
                                   nil #'vl-load-packages-incrementally
                                   packages t)
              (setq packages nil)))))))

  (defun vl-load-packages-incrementally-h ()
    "Begin incrementally loading packages in `doom-incremental-packages'.

  If this is a daemon session, load them all immediately instead."
    (if vl-incremental-load-immediately
        (mapc #'require (cdr vl-incremental-packages))
      (when (numberp vl-incremental-first-idle-timer)
        (run-with-idle-timer vl-incremental-first-idle-timer
                             nil #'vl-load-packages-incrementally
                             (cdr vl-incremental-packages) t))))

  (add-hook 'emacs-startup-hook #'vl-load-packages-incrementally-h)

  (with-eval-after-load 'use-package-core
    (eval-and-compile
      ;; `use-package' adds syntax highlighting for the `use-package' macro, but
      ;; Emacs 26+ already highlights macros, so it's redundant.
      (font-lock-remove-keywords 'emacs-lisp-mode use-package-font-lock-keywords)

      ;; We define :minor and :magic-minor from the `auto-minor-mode' package here
      ;; so we don't have to load `auto-minor-mode' so early.
      (dolist (keyword '(:minor :magic-minor))
        (setq use-package-keywords
              (use-package-list-insert keyword use-package-keywords :commands)))

      (defalias 'use-package-normalize/:minor #'use-package-normalize-mode)
      (defun use-package-handler/:minor (name _ arg rest state)
        (use-package-handle-mode name 'auto-minor-mode-alist arg rest state))

      (defalias 'use-package-normalize/:magic-minor #'use-package-normalize-mode)
      (defun use-package-handler/:magic-minor (name _ arg rest state)
        (use-package-handle-mode name 'auto-minor-mode-magic-alist arg rest state))

      ;; Adds two keywords to `use-package' to expand its lazy-loading capabilities:
      ;;
      ;;   :after-call SYMBOL|LIST
      ;;   :defer-incrementally SYMBOL|LIST|t
      ;;
      ;; Check out `use-package!'s documentation for more about these two.
      (dolist (keyword '(:defer-incrementally :after-call))
        (push keyword use-package-deferring-keywords)
        (setq use-package-keywords
              (use-package-list-insert keyword use-package-keywords :after)))

      (defalias 'use-package-normalize/:defer-incrementally #'use-package-normalize-symlist)
      (defun use-package-handler/:defer-incrementally (name _keyword targets rest state)
        (use-package-concat
         `((vl-load-packages-incrementally
            ',(if (equal targets '(t))
                  (list name)
                (append targets (list name)))))
         (use-package-process-keywords name rest state)))

      (defalias 'use-package-normalize/:after-call #'use-package-normalize-symlist)
      (defun use-package-handler/:after-call (name _keyword hooks rest state)
        (if (plist-get state :demand)
            (use-package-process-keywords name rest state)
          (let ((fn (make-symbol (format "vl--after-call-%s-h" name))))
            (use-package-concat
             `((fset ',fn
                     (lambda (&rest _)
                       (message "Loading deferred package %s from %s" ',name ',fn)
                       (condition-case e
                           (require ',name)
                         ((debug error)
                          (message "Failed to load deferred package %s: %s" ',name e)))
                       (when-let (deferral-list (assq ',name vl--deferred-packages-alist))
                         (dolist (hook (cdr deferral-list))
                           (advice-remove hook #',fn)
                           (remove-hook hook #',fn))
                         (setq vl--deferred-packages-alist (delq deferral-list vl--deferred-packages-alist))
                         (unintern ',fn nil)))))
             (let (forms)
               (dolist (hook hooks forms)
                 (push (if (string-match-p "-\\(?:functions\\|hook\\)$" (symbol-name hook))
                           `(add-hook ',hook #',fn)
                         `(advice-add #',hook :before #',fn))
                       forms)))
             `((unless (assq ',name vl--deferred-packages-alist)
                 (push '(,name) vl--deferred-packages-alist))
               (nconc (assq ',name vl--deferred-packages-alist)
                      '(,@hooks)))
             (use-package-process-keywords name rest state)))))))
#+end_src

*** Server

#+begin_src emacs-lisp
  (use-package server
    :ensure nil
    :when (display-graphic-p)
    :after-call vl-first-input-hook
    :config
    (unless (server-running-p)
      (server-start)))
#+end_src

*** No-littering
#+begin_src emacs-lisp
  (use-package no-littering
    :demand t
    :config
    ;; if something wouldn't have been native compiled at build time
    (when (boundp 'native-comp-eln-load-path)
      (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache" no-littering-var-directory)))
    (setq custom-file (expand-file-name "settings.el" no-littering-etc-directory))
    (load custom-file 'noerror))
#+end_src

*** Startup

#+begin_src emacs-lisp
  ;; performance considerations
  (use-package gcmh
    :hook (after-init . gcmh-mode)
    :init
    (setq gcmh-idle-delay 5
          gcmh-high-cons-threshold (* 16 1024 1024)))
#+end_src

Idea of a =vl-first-input-hook= is borrowed from =doom-emacs=

#+begin_src emacs-lisp
  (defvar vl-first-input-hook nil
    "Run FUNCTION exactly once at first `pre-command-hook' execution time.")
  (put 'vl-first-input-hook 'permanent-local t)

  (defun vl--run-at-first-input ()
    (run-hooks 'vl-first-input-hook)
    (remove-hook 'pre-command-hook #'vl--run-at-first-input))

  (add-hook 'pre-command-hook #'vl--run-at-first-input)
#+end_src

** Key binding
#+begin_src emacs-lisp
  (use-package evil
    :hook
    (after-init . evil-mode)
    :init
    (setq evil-want-integration t
          evil-want-keybinding nil
          evil-want-C-u-scroll nil ;; C-b scrolls symilarly
          evil-want-C-i-jump nil
          evil-undo-system 'undo-tree
          evil-want-fine-undo t
          evil-search-module 'isearch
          evil-symbol-word-search t)
    :config
    (use-package undo-tree
      :init (setq undo-tree-auto-save-history t)
      :config (global-undo-tree-mode))

    (defun vl-set-shift-width ()
      (setq evil-shift-width tab-width))
    (add-hook 'after-change-major-mode-hook #'vl-set-shift-width)
    (dolist (mode '(custom-mode
                    eshell-mode
                    git-rebase-mode
                    term-mode))
      (add-to-list 'evil-emacs-state-modes mode))

    (evil-set-initial-state 'messages-buffer-mode 'normal)

    )
    (use-package evil-collection
      :after evil
      :config
      (evil-collection-init))

  ;; Make ESC quit prompts
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)
  (global-set-key (kbd "M-u") 'upcase-dwim)
  (global-set-key (kbd "M-l") 'downcase-dwim)
  (global-set-key (kbd "M-c") 'capitalize-dwim)

#+end_src

In visual mode =S<textobj>=, =gS<textobj>,= in normal mode =ys<textobj>= or =yS<textobj>=. =cs<textobj><textobj>= and =ds<textobj>= are also DWIM.
#+begin_src emacs-lisp
  (use-package evil-surround
    :hook
    (vl-first-input . global-evil-surround-mode))
#+end_src


#+begin_src emacs-lisp
  (use-package evil-snipe
    :hook
    (vl-first-input . evil-snipe-mode)
    (vl-first-input . evil-snipe-override-mode))

  (use-package evil-easymotion
    :after-call vl-first-input-hook
    :commands evilem-create evilem-default-keybindings
    :config
    (evilem-default-keybindings "g s")
    ;; Use evil-search backend, instead of isearch
    (evilem-make-motion evilem-motion-search-next #'evil-ex-search-next
                        :bind ((evil-ex-search-highlight-all nil)))
    (evilem-make-motion evilem-motion-search-previous #'evil-ex-search-previous
                        :bind ((evil-ex-search-highlight-all nil)))
    (evilem-make-motion evilem-motion-search-word-forward #'evil-ex-search-word-forward
                        :bind ((evil-ex-search-highlight-all nil)))
    (evilem-make-motion evilem-motion-search-word-backward #'evil-ex-search-word-backward
                        :bind ((evil-ex-search-highlight-all nil)))

    ;; Rebind scope of w/W/e/E/ge/gE evil-easymotion motions to the visible
    ;; buffer, rather than just the current line.
    (put 'visible 'bounds-of-thing-at-point (lambda () (cons (window-start) (window-end))))
    (evilem-make-motion evilem-motion-forward-word-begin #'evil-forward-word-begin :scope 'visible)
    (evilem-make-motion evilem-motion-forward-WORD-begin #'evil-forward-WORD-begin :scope 'visible)
    (evilem-make-motion evilem-motion-forward-word-end #'evil-forward-word-end :scope 'visible)
    (evilem-make-motion evilem-motion-forward-WORD-end #'evil-forward-WORD-end :scope 'visible)
    (evilem-make-motion evilem-motion-backward-word-begin #'evil-backward-word-begin :scope 'visible)
    (evilem-make-motion evilem-motion-backward-WORD-begin #'evil-backward-WORD-begin :scope 'visible)
    (evilem-make-motion evilem-motion-backward-word-end #'evil-backward-word-end :scope 'visible)
    (evilem-make-motion evilem-motion-backward-WORD-end #'evil-backward-WORD-end :scope 'visible))
#+end_src


#+begin_src emacs-lisp
  (use-package general
    :demand t
    :config
    (defun +kill-this-buffer ()
      (interactive)
      (let ((buffer-modified-p nil))
        (kill-buffer (current-buffer))))
    (eval-and-compile
      (general-create-definer global-leader-prefix
        :states '(emacs normal visual motion insert)
        :keymaps 'override
        :prefix "SPC"
        :non-normal-prefix "M-SPC")
      (general-create-definer local-leader-prefix
        :states '(normal visual motion insert emacs)
        :major-modes t
        :prefix "SPC m"
        :non-normal-prefix "M-SPC m"
        :global-prefix "M-m"))
    (global-leader-prefix
      "" '(nil :which-key "<leader>")
      "b" '(:ignore t :which-key "buffers")
      "b d" '+kill-this-buffer
      "f" '(:ignore t :which-key "files")
      "f f" 'find-file
      "g" '(:ignore t :which-key "git")
      "h" '(:keymap help-map t :which-key "help")
      "m" '(:ignore t :which-key "<localleader>")
      "w" '(:ignore t :which-key "windows")
      "w d" 'delete-window
      "p" '(:ignore t :which-key "projects")
      "s" '(:ignore t :which-key "search"))
    )
#+end_src

** UI setup

For popup management

#+begin_src emacs-lisp
  (use-package popper
    :bind (("C-`"   . popper-toggle-latest)
           ("M-`"   . popper-cycle)
           ("C-M-`" . popper-toggle-type))
    :hook (after-init . popper-mode)
    :config
    ;;(setq popper-group-function #'popper-group-by-project)
    :init
    (setq popper-display-control nil)
    (setq popper-reference-buffers
          '("\\*Warning"
            "Output\\*\\'"
            "\\*Backtrace\\*"
            flycheck-error-list-mode
            messages-buffer-mode
            help-mode
            helpful-mode
            compilation-mode)))

  (use-package window
    :ensure nil
    :general
    (global-leader-prefix
      "w t" '(window-toggle-side-windows :wk "toggle side windows"))
    :custom
    ;; Kill a frame when quitting its only window
    (frame-auto-hide-function 'delete-frame)
    ;; Maximum number of side-windows to create on (left top right bottom)
    (window-sides-slots '(1 1 3 3))
    ;; Default rules
    (display-buffer-alist
     `(;; Display *Help* buffer at the right
       ("\\*\\(Help\\|company-documentation\\)"
        (display-buffer-reuse-window display-buffer-in-previous-window display-buffer-in-side-window)
        (side . right)
        (slot . 0)
        (window-width . 0.33)
        (reusable-frames . visible))
       ("\\(magit: \\|COMMIT_EDITMSG\\)"
        (display-buffer-reuse-window display-buffer-in-previous-window display-buffer-in-side-window)
        (side . right)
        (slot . -1)
        (window-width . 0.2)
        (reusable-frames . visible))
       ("\\*\\(Messages\\|Backtrace\\|Warnings\\|Output\\|Flycheck\\)"
        (display-buffer-reuse-window display-buffer-in-previous-window display-buffer-in-side-window)
        (side . bottom)
        (slot . 0)
        (window-height . 16)
        (reusable-frames . visible))
       ("^\\*info"
        (display-buffer-reuse-window display-buffer-in-previous-window display-buffer-pop-up-frame)
        (pop-up-frame-parameters
         (minibuffer . nil)
         (tab-line-mode . nil)
         (width . 80)
         (left . 1.0)
         (fullscreen . fullheight)))
       ;; Split shells at the bottom
       ("^\\*e?shell"
        (display-buffer-reuse-window display-buffer-in-previous-window display-buffer-below-selected)
        (window-min-height . 20)
        (reusable-frames . visible))))
    :commands vl-display-buffer-bottom-side
    :config
    (defun vl-display-buffer-bottom-side (buffer)
      (let ((window (display-buffer-in-side-window
                     buffer `((side . bottom)
                              (slot . 0)
                              (window-height . 0.25)
                              (window-parameters . ((no-other-window . t)
                                                    (no-delete-other-windows . t)))))))
        (select-window window))))
#+end_src

#+begin_src emacs-lisp
  (use-package hydra
    :defer t)
#+end_src

#+begin_src emacs-lisp
  (use-package winner
    :ensure nil
    :hook (window-setup . winner-mode))
#+end_src

*** Modeline

#+begin_src emacs-lisp
  (use-package doom-modeline
    :hook (after-init . doom-modeline-mode)
    :hook (doom-modeline-mode . size-indication-mode)
    :hook (doom-modeline-mode . column-number-mode)
    :init
    (setq doom-modeline-hud t
          doom-modeline-buffer-file-name-style 'truncate-upto-project
          doom-modeline-buffer-encoding 'nondefault
          doom-modeline-default-eol-type 0))

  (use-package minions
    :hook
    (after-init . minions-mode))

  (use-package anzu
    :hook
    (after-init . global-anzu-mode))
#+end_src

*** Themes
#+begin_src emacs-lisp
  (use-package doom-themes
    :init
    (doom-themes-treemacs-config))
#+end_src

#+begin_src emacs-lisp
  (use-package modus-themes
    :bind ("<f10>" . modus-themes-toggle)
    :custom
    (modus-themes-italic-constructs t)
    (modus-themes-bold-constructs t)
    (modus-themes-mode-line 'borderless)
    (modus-themes-region '(bg-only no-extend))
    (modus-themes-org-blocks 'gray-background)
    (modus-themes-syntax 'faint)
    (modus-themes-lang-checkers 'straight-underline)
    (modus-themes-headings '((1 . (rainbow background overline))
                             (2 . (background overline))
                             (3 . (background overline))
                             (4 . (background overline))
                             (5 . (overline))
                             (t . (no-bold))))
    (modus-themes-scale-headings t)
    (modus-themes-scale-1 1.2)
    (modus-themes-scale-2 1.3)
    (modus-themes-scale-3 1.4)
    (modus-themes-scale-4 1.5)
    (modus-themes-scale-title 2.0)
    :init
    (modus-themes-load-themes)
    (modus-themes-load-operandi))
#+end_src

*** Which-key
#+begin_src emacs-lisp
  (use-package which-key
    :hook (vl-first-input . which-key-mode)
    :init
    (setq which-key-idle-delay 1))
#+end_src

** Completion framework
#+begin_src emacs-lisp
  (defun vl-minibuffer-backward-kill (arg)
  "When minibuffer is completing a file name delete up to parent
  folder, otherwise delete a word"
  (interactive "p")
  (if minibuffer-completing-file-name
      ;; Borrowed from https://github.com/raxod502/selectrum/issues/498#issuecomment-803283608
      (if (string-match-p "/." (minibuffer-contents))
          (zap-up-to-char (- arg) ?/)
        (delete-minibuffer-contents))
    (backward-kill-word arg)))

  (use-package vertico
    :bind (:map vertico-map
                ("C-j" . vertico-next)
                ("C-k" . vertico-previous)
                ("C-f" . vertico-exit)
                :map minibuffer-local-map
                ("M-h" . vl-minibuffer-backward-kill))
    :custom
    (vertico-cycle t)
    (vertico-buffer-display-action
     `(display-buffer-at-bottom
       (window-height . ,(+ 3 vertico-count))))
    :hook (after-init . vertico-mode)
    :config
    (vertico-buffer-mode))

  (use-package orderless
    :defer t
    :init
    (setq completion-styles '(orderless)
          completion-category-defaults nil
          completion-category-overrides '((file (styles partial-completion)))))

  (use-package emacs
    :ensure nil
    :init
    ;; Add prompt indicator to `completing-read-multiple'.
    ;; Alternatively try `consult-completing-read-multiple'.
    (defun crm-indicator (args)
      (cons (concat "[CRM] " (car args)) (cdr args)))
    (advice-add #'consult-completing-read-multiple :filter-args #'crm-indicator)

    ;; Do not allow the cursor in the minibuffer prompt
    (setq minibuffer-prompt-properties
          '(read-only t cursor-intangible t face minibuffer-prompt))
    (add-hook 'minibuffer-setup-hook #'cursor-intangible-mode)
    ;; Emacs 28: Hide commands in M-x which do not work in the current mode.
    ;; Vertico commands are hidden in normal buffers.
    (setq read-extended-command-predicate
          #'command-completion-default-include-p)

    ;; Enable recursive minibuffers
    (setq enable-recursive-minibuffers t))

  (use-package marginalia
    :hook (after-init . marginalia-mode)
    :bind (:map minibuffer-local-map
                ("M-A" . marginalia-cycle)))

#+end_src
*** Extra completion
#+begin_src emacs-lisp
  (use-package consult
    ;; Replace bindings. Lazily loaded due by `use-package'.
    :general
    (global-leader-prefix
      "b b" '(consult-buffer :wk "Buffers & recents")
      "b n" '(:ignore t :wk "Open buffer in...")
      "b n f" '(consult-buffer-other-frame :wk "New frame")
      "b n w" '(consult-buffer-other-window :wk "New window")
      "f r" '(consult-recent-file :wk "Recent files")
      "h M" '(consult-man :wk "Show a man page")
      "b m" 'consult-bookmark
      "s p" '(consult-ripgrep :wk "Search in project")
      "s i" '(consult-imenu :wk "Go-to item")
      "s o" '(consult-outline :wk "Go-to outline")
      "s s" '(consult-line :wk "Search in current buffer")
      "s /" '(consult-line :wk "Search in current buffer")
      "s &" '(consult-focus-lines :wk "Filter matching lines")
      "s :" '(consult-goto-line :wk "Jump to line number"))
    :bind (;; C-c bindings (mode-specific-map)
           ("C-c h" . consult-history)
           ("C-c m" . consult-mode-command)
           ("C-c b" . consult-bookmark)
           ("C-c k" . consult-kmacro)
           ;; C-x bindings (ctl-x-map)
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ("<help> a" . consult-apropos)            ;; orig. apropos-command
           ;; M-g bindings (goto-map)
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-project-imenu)
           ;; M-s bindings (search-map)
           ("M-s f" . consult-find)
           ("M-s L" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s m" . consult-multi-occur)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch)
           :map isearch-mode-map
           ("M-e" . consult-isearch)                 ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch)               ;; orig. isearch-edit-string
           ("M-s l" . consult-line))                 ;; needed by consult-line to detect isearch

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Optionally replace `completing-read-multiple' with an enhanced version.
    (advice-add #'completing-read-multiple :override #'consult-completing-read-multiple)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    (setq completion-in-region-function 'consult-completion-in-region)
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key (kbd "M-."))
    ;; (setq consult-preview-key (list (kbd "<S-down>") (kbd "<S-up>")))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme
     :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-file consult--source-project-file consult--source-bookmark
     :preview-key (kbd "M-."))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; (kbd "C-+")

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (define-key consult-narrow-map (vconcat consult-narrow-key "?") #'consult-narrow-help)

    ;; Optionally configure a function which returns the project root directory.
    ;; There are multiple reasonable alternatives to chose from.
    ;;;; 1. project.el (project-roots)
    ;;(setq consult-project-root-function
    ;;      (lambda ()
    ;;        (when-let (project (project-current))
    ;;          (car (project-roots project)))))
    ;; 2. projectile.el (projectile-project-root)
    (autoload 'projectile-project-root "projectile")
    (setq consult-project-root-function #'projectile-project-root)
    ;;;; 3. vc.el (vc-root-dir)
    ;; (setq consult-project-root-function #'vc-root-dir)
    ;;;; 4. locate-dominating-file
    ;; (setq consult-project-root-function (lambda () (locate-dominating-file "." ".git")))
    )
#+end_src


#+begin_src emacs-lisp
  (use-package consult-dir
    :bind (("C-x C-d" . consult-dir)
           :map vertico-map
           ("C-x C-d" . consult-dir)
           ("C-x C-j" . consult-dir-jump-file)))
#+end_src

#+begin_src emacs-lisp
  (use-package embark
    :general
    (global-leader-prefix
      "." '(embark-act :wk "Contextual Actions")
      ";" '(embark-dwim :wk "Contextual Actions DWIM"))
    ("C-;" 'embark-act)
    ("C-:" 'embark-dwim)
    :init
    (setq embark-indicators
          '(embark-minimal-indicator
            embark-highlight-indicator
            embark-isearch-highlight-indicator)))

  (use-package embark-consult
    :after (embark consult)
    :hook
    (embark-collect-mode . embark-consult-preview-minor-mode))
#+end_src
** Helpful
#+begin_src emacs-lisp
  (use-package helpful
    :hook (helpful-mode . visual-line-mode)
    :bind
    ([remap describe-command] . helpful-command)
    ([remap describe-function] . helpful-callable)
    ([remap describe-macro] . helpful-macro)
    ([remap describe-mode] . helpful-mode)
    ([remap describe-key] . helpful-key)
    ([remap describe-symbol] . helpful-symbol)
    ([remap describe-variable] . helpful-variable))
#+end_src
** Projectile
#+begin_src emacs-lisp
  (use-package projectile
    :hook (after-init . projectile-mode)
    :general
    (global-leader-prefix
      "SPC" '(projectile-find-file :wk "Open file from project")
      "," '(projectile-switch-to-buffer :wk "Switch to project buffer")
      "p b" '(projectile-switch-to-buffer :wk "Switch to project buffer")
      "p f" '(projectile-find-file :wk "Open file from project")
      "p p" '(projectile-switch-project :wk "Open project")))
#+end_src

** Tree
#+begin_src emacs-lisp
  (use-package treemacs
    :defer t
    :init
    (with-eval-after-load 'winum
      (define-key winum-keymap (kbd "M-0") #'treemacs-select-window))
    :config
    (setq
     treemacs-follow-after-init t
     treemacs-is-never-other-window t
     treemacs-sorting 'alphabetic-case-insensitive-asc
     treemacs-position     'left
     treemacs-width        35)

    (treemacs-tag-follow-mode t)
    (treemacs-filewatch-mode t)
    (treemacs-fringe-indicator-mode t)
    (treemacs-git-mode 'deferred)
    :bind
    (:map global-map
          ("M-0"       . treemacs-select-window)
          ("C-x t 1"   . treemacs-delete-other-windows)
          ("C-x t t"   . treemacs)
          ("C-x t B"   . treemacs-bookmark)
          ("C-x t C-t" . treemacs-find-file)
          ("C-x t M-t" . treemacs-find-tag)))

  (use-package treemacs-evil
    :after (treemacs evil))

  (use-package treemacs-projectile
    :after (treemacs projectile))

  (use-package treemacs-magit
    :after (treemacs magit))
  (use-package treemacs-persp ;;treemacs-persective if you use perspective.el vs. persp-mode
    :after treemacs persp-mode ;;or perspective vs. persp-mode
    :config (treemacs-set-scope-type 'Perspectives))
#+end_src
** Misc
#+begin_src emacs-lisp
  (use-package savehist
    :ensure nil
    :hook (pre-command . savehist-mode))

  (use-package recentf
    :ensure nil
    :custom
    (recentf-max-saved-items 1000)
    :hook (after-init . (lambda()
              (recentf-mode 1)
              (add-to-list 'recentf-exclude no-littering-var-directory)
              (add-to-list 'recentf-exclude no-littering-etc-directory)
              (add-to-list 'recentf-exclude user-emacs-directory)
              (run-at-time nil (* 5 60) 'recentf-save-list))))

  (defalias 'yes-or-no-p 'y-or-n-p)

  (use-package vterm
    :commands vterm-mode vl-vterm-popup
    :after window
    :config
    (defun vl-vterm-popup (&optional arg)
      (interactive "P")
      (let* ((project-root (or (projectile-project-root) default-directory))
             (default-directory (if arg default-directory project-root)))
        (vterm--internal #'vl-display-buffer-bottom-side)))
    :general
    (global-leader-prefix
      "o t" '(vl-vterm-popup :wk "vterm popup")))
#+end_src
** Font

#+begin_src emacs-lisp
  (defvar vl-default-font (font-spec :name "Iosevka Extended" :size 14))
  (defvar vl-sans-font (font-spec :name "Iosevka Aile" :size 14))
  (defvar vl-serif-font (font-spec :name "ETBembo" :size 14))
  (set-face-attribute 'variable-pitch nil :font vl-sans-font)
  (set-face-attribute 'fixed-pitch nil :font vl-default-font)
  (set-face-attribute 'default nil :font vl-default-font)
  (add-to-list 'default-frame-alist
               `(font . ,(font-xlfd-name vl-default-font)))
#+end_src

Emoji support: http://ergoemacs.org/emacs/emacs_list_and_set_font.html
#+begin_src emacs-lisp
  ;; set font for emoji
  (set-fontset-font
   t
   'symbol
    "Noto Color Emoji")
#+end_src

#+begin_src emacs-lisp
  (use-package ligature
    :demand t
    :config
    ;; Enable all Iosevka ligatures in programming modes
    (ligature-set-ligatures 'prog-mode '("<---" "<--"  "<<-" "<-" "->" "-->" "--->" "<->" "<-->" "<--->" "<---->" "<!--"
                                         "<==" "<===" "<=" "=>" "=>>" "==>" "===>" ">=" "<=>" "<==>" "<===>" "<====>" "<!---"
                                         "<~~" "<~" "~>" "~~>" "::" ":::" "==" "!=" "===" "!=="
                                         ":=" ":-" ":+" "<*" "<*>" "*>" "<|" "<|>" "|>" "+:" "-:" "=:" "<******>" "++" "+++"))
    ;; Enables ligature checks globally in all buffers. You can also do it
    ;; per mode with `ligature-mode'.
    (global-ligature-mode t))
#+end_src

** Magit
#+begin_src emacs-lisp
  (use-package magit
    :defer t
    :defer-incrementally dash f s with-editor git-commit package eieio transient
    :general
    (global-leader-prefix
      :infix "g"
      "g" 'magit-status
      "b" 'magit-blame-addition
      "l" 'magit-log-head)
    :custom
    (magit-display-buffer-function #'magit-display-buffer-fullcolumn-most-v1)
    (magit-save-repository-buffers nil))

  (use-package transient-posframe
    :hook (vl-first-input . transient-posframe-mode))
#+end_src

#+begin_src emacs-lisp
  (use-package diff-hl
    :hook (text-mode . diff-hl-mode)
    :hook (prog-mode . diff-hl-mode)
    :hook (dired-mode . diff-hl-dired-mode-unless-remote)
    :hook (magit-post-refresh . diff-hl-magit-post-refresh)
    :general
    (global-leader-prefix
      "g r" 'diff-hl-revert-hunk
      "g d" 'diff-hl-show-hunk)
    :config
    (setq diff-hl-show-hunk-function #'diff-hl-show-hunk-posframe)
    (fringe-mode '8))
#+end_src

** Basic editing
#+begin_src emacs-lisp
  (setq-default
   indent-tabs-mode nil
   tab-width 4
   require-final-newline t
   view-read-only t)

  ;; Controls language and format of dates
  (setq system-time-locale "en_US"
        calendar-week-start-day 1)

  (use-package emacs
    :hook (prog-mode . (lambda () (setq show-trailing-whitespace t))))

  (use-package tab-line
    :ensure nil
    :hook (after-init . (lambda()(global-tab-line-mode 1))))

  (use-package display-fill-column-indicator
    :ensure nil
    :hook (prog-mode . (lambda()(display-fill-column-indicator-mode 1))))

  (use-package ws-butler
    :hook
    (prog-mode . ws-butler-mode)
    (text-mode . ws-butler-mode)
    :init
    (setq ws-butler-trim-predicate
          (lambda (beg end)
            (not (eq 'font-lock-string-face
                     (get-text-property end 'face))))))

  (setq view-read-only t)
  ;; UTF-8 as default encoding
  (set-language-environment "UTF-8")
  (set-default-coding-systems 'utf-8-unix)

#+end_src
** Org mode
#+begin_src emacs-lisp
  (defun vl-org-toggle-markup ()
    (interactive)
    (let* ((current-value org-hide-emphasis-markers)
           (toggled (not current-value))
           (status (concat "Markup is " (if toggled "hidden" "visible"))))
      (if toggled
          (add-to-invisibility-spec '(org-link))
        (remove-from-invisibility-spec '(org-link)))
      (setq-local org-hide-emphasis-markers toggled)
      (font-lock-flush)
      (font-lock-ensure)
      (message "%s" status)))

  (defun vl--setup-org ()
    (custom-declare-face 'vl-org-next    '((t (:inherit (underline org-todo)))) "")
    (custom-declare-face 'vl-org-active  '((t (:inherit (bold org-scheduled org-todo)))) "")
    (custom-declare-face 'vl-org-project '((t (:inherit (bold font-lock-doc-face org-todo)))) "")
    (custom-declare-face 'vl-org-onhold  '((t (:inherit (bold warning org-todo) :inverse-video t))) "")
    (custom-declare-face 'vl-org-someday '((t (:inherit (shadow org-todo)))) "")
    (custom-declare-face 'vl-org-cancel  '((t (:inherit (org-archived org-todo)))) "")

    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("nix" . "src nix"))
    (add-to-list 'org-structure-template-alist '("py" . "src python"))
    (add-to-list 'org-structure-template-alist '("sh" . "src sh"))

    ;; Save Org buffers after refiling!
    (advice-add 'org-refile :after 'org-save-all-org-buffers)

    (org-babel-do-load-languages
     'org-babel-load-languages
     '((emacs-lisp . t)
       (python . t)
       (shell . t))))

  (use-package visual-line-mode
    :ensure nil
    :hook org-mode)

  (use-package org
    :defer-incrementally
    calendar find-func format-spec org-macs org-compat org-faces org-entities
    org-list org-pcomplete org-src org-footnote org-macro ob org org-agenda
    org-capture org-habit org-inlinetask org-tempo
    :hook (org-load . vl--setup-org)
    :general
    (global-leader-prefix
      "c" 'org-capture
      "a" 'org-agenda)
    (global-leader-prefix
      :infix "n"
      "" '(:ignore t :which-key "notes")
      "n" 'org-capture
      "N" 'org-capture-goto-target
      "t" 'org-todo-list)
    (local-leader-prefix
      :keymaps 'org-mode-map
      "m" '(vl-org-toggle-markup :wk "toggle-markup"))
    :init
    (setq vl-org-agenda-dir (expand-file-name "agenda" org-directory))
    :custom
    (org-modules
     '(;; ol-w3m
       ;; ol-bbdb
       ol-bibtex
       ;; ol-docview
       ;; ol-gnus
       ;; ol-info
       ;; ol-irc
       ;; ol-mhe
       ;; ol-rmail
       ;; ol-eww
       ))
    (org-ellipsis " ‚ñæ")
    (org-hide-emphasis-markers t)
    (org-src-fontify-natively t)
    (org-fontify-quote-and-verse-blocks t)
    (org-src-tab-acts-natively t)
    (org-edit-src-content-indentation 2) ;; 0
    (org-hide-block-startup nil)
    (org-src-preserve-indentation nil)
    (org-startup-folded 'content)
    (org-startup-indented t)
    (org-startup-with-inline-images t)
    (org-image-actual-width '(300))
    (org-list-indent-offset 4)
    (org-cycle-separator-lines 2)
    (org-agenda-start-with-log-mode t)
    (org-log-done 'time)
    (org-log-into-drawer t)
    (org-habit-graph-column 60)
    (org-agenda-span 10)
    (org-agenda-start-on-weekday nil)  ;; start relative to today
    (org-refile-targets '((nil :maxlevel . 3)
                          (org-agenda-files :maxlevel . 3)))
    ;; include file name in refile completion
    (org-refile-use-outline-path 'file)
    ;; display the full path in the completion buffer immediately
    (org-outline-path-complete-in-steps nil)
    (org-treat-insert-todo-heading-as-state-change t)
    (org-todo-keywords
     ;; KEYWORD[([<hotkey>][<enter action>/<exit action>|<action>])
     ;; @: record note and timestamp
     ;; !: record timestamp
     '((sequence
        "TODO(t)"
        "NEXT(n)"
        "TODAY(T)"
        "PROJECT(p)"
        "IN-PROGRESS(i)"
        "WAITING(w@/!)"
        "HOLD(h)"
        "SOMEDAY(s)"
        "|"
        "DONE(d!)"
        "CANCELED(c@)")
       (sequence "|" "YES" "NO")))
    (org-todo-keyword-faces
     '(("NEXT" . vl-org-next)
       ("TODAY" . vl-org-next)
       ("IN-PROGRESS" . vl-org-active)
       ("WAITING" . vl-org-onhold)
       ("HOLD" . vl-org-onhold)
       ("PROJECT" . vl-org-project)
       ("SOMEDAY" . vl-org-someday)
       ("CANCELLED" . vl-org-cancel)
       ("NO"   . vl-org-cancel)))
    (org-default-notes-file (expand-file-name "notes.org" org-directory))
    (org-agenda-files `(,vl-org-agenda-dir))
    (org-capture-templates
     (let ((todo-file (expand-file-name "todo.org" vl-org-agenda-dir))
           (personal-file (expand-file-name "personal.org" vl-org-agenda-dir)))
       `(("t" "Todo" entry
          (file+headline ,todo-file "Inbox")
          "* TODO %?\n%i\n%a")
         ("n" "Note" entry
          (file+headline ,todo-file "Inbox")
          "* %u %?\n%i\n%a")
         ("l" "link" entry
          (file+headline ,todo-file "Inbox")
          "* %u %(org-cliplink-capture)" :immediate-finish t)
         ("c" "org-protocol-capture" entry
          (file+headline ,todo-file "Inbox")
          "* %u [[%:link][%:description]]\n%i" :immediate-finish t)
         ("b" "Book" entry
          (file+olp ,personal-file "Hobbies" "Reading")
          "* TODO \n:PROPERTIES:\n:ADDED: %<[%Y-%02m-%02d]>\n:END%^{AUTHOR}p"))))
    (org-agenda-custom-commands
     `(("n" "Agenda and all TODOs"
        ((agenda "")
         (alltodo "")))
       ("d" "Daily schedule"
        ((agenda ""
                 ((org-agenda-span 'day)
                  (org-agenda-use-time-grid nil)
                  (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled 'deadline))))))

       )))

  (use-package org-cliplink
    :after org-capture)

  (use-package org-variable-pitch
    :hook (org-mode . org-variable-pitch-minor-mode))

  (use-package org-appear
    :hook (org-mode . org-appear-mode))

  (use-package org-superstar
    :hook (org-mode . org-superstar-mode)
    :custom
    (org-superstar-remove-leading-stars t)
    (org-superstar-headline-bullets-list '("‚Ä∫")))

  (use-package olivetti
    :hook (org-mode . olivetti-mode)
    :init
    (setq olivetti-body-width 120))

  (defun vl--get-daily-agenda (&optional date)
    "Return the agenda for the DATE as a string."
    (interactive)
    (let ((file (make-temp-file "daily-agenda" nil ".txt")))
      (org-agenda nil "d" nil)
      (when date (org-agenda-goto-date date))
      (org-agenda-write file nil nil "*Org Agenda(d)*")
      (kill-buffer)
      (with-temp-buffer
        (insert-file-contents file)
        (goto-char (point-min))
        (kill-line 2)
        (while (re-search-forward "^  " nil t)
          (replace-match "- " nil nil))
        (buffer-string))))


  (use-package org-roam
    :general
    (global-leader-prefix
      :infix "r"
      "" '(:ignore t :which-key "roam")
      "l" 'org-roam-buffer-toggle
      "f" 'org-roam-node-find
      "g" 'org-roam-graph
      "i" 'org-roam-node-insert
      "c" 'org-roam-capture
      ;; Dailies
      "d" '(:keymap org-roam-dailies-map :package org-roam-dailies :which-key "dailies"))
    :init
    (setq org-roam-v2-ack t)
    :custom
    (org-roam-directory (expand-file-name "roam" org-directory))
    (org-roam-dailies-capture-templates
     (let ((head
            (concat "#+title: %<%Y-%m-%d (%A)>\n#+startup: showall\n* Daily Overview\n"
                    "#+begin_src emacs-lisp :results value raw\n"
                    "(vl--get-daily-agenda \"%<%Y-%m-%d>\")\n"
                    "#+end_src\n"
                    "* [/] Do Today\n* [/] Maybe Do Today\n* Journal\n")))
       `(("j" "journal" entry
          "* %<%H:%M> %?"
          :if-new (file+head+olp "%<%Y-%m-%d>.org" ,head ("Journal")))
         ("t" "do today" item
          "[ ] %a"
          :if-new (file+head+olp "%<%Y-%m-%d>.org" ,head ("Do Today"))
          :immediate-finish t)
         ("m" "maybe do today" item
          "[ ] %a"
          :if-new (file+head+olp "%<%Y-%m-%d>.org" ,head ("Maybe Do Today"))
          :immediate-finish t))))
    :config
    (org-roam-setup)
    ;; If using org-roam-protocol
    (require 'org-roam-protocol)
    (setq org-roam-capture-ref-templates
          '(("r" "ref" plain "%?" :if-new (file+head "web/${slug}.org" "#+title: ${title}\n\n#+begin_quote\n${body}\n#+end_quote")
             :unnarrowed t))))

  (use-package websocket
    :defer t)

  (use-package simple-httpd
    :defer t)

  (use-package org-roam-ui
        :after org-roam ;; or :after org
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

  (use-package git-auto-commit-mode
    :defer t)
#+end_src

** Dired

#+begin_src emacs-lisp
  (defun vl-unless-remote (fn)
    (unless (file-remote-p default-directory)
      (funcall fn)))
  (use-package dired
    :ensure nil
    :defer t
    :init
    (setq dired-dwim-target t
          dired-auto-revert-buffer t
          dired-kill-when-opening-new-dired-buffer t
          dired-recursive-copies 'always
          dired-recursive-deletes 'top
          dired-listing-switches "-ahlv --group-directories-first"))

  (use-package dired-collapse)
  (use-package dired-narrow)
  (use-package dired-open)
  (use-package dired-rainbow)
  (use-package dired-ranger)
  (use-package dired-subtree
    :bind (:map dired-mode-map
                ("TAB". dired-subtree-cycle)))

  (use-package diredfl
    :hook (dired-mode . (lambda () (vl-unless-remote #'diredfl-mode))))
  (use-package all-the-icons-dired
    :hook (dired-mode . (lambda () (vl-unless-remote #'all-the-icons-dired-mode))))
  (use-package dired-x
    :ensure nil
    :hook (dired-mode . dired-omit-mode))
#+end_src

** Programming
#+begin_src emacs-lisp
  (use-package paren
    :ensure nil
    :hook (prog-mode . show-paren-mode))

  (use-package display-line-numbers
    :ensure nil
    :hook (prog-mode . display-line-numbers-mode))

  (use-package smart-newline
    :hook (prog-mode . smart-newline-mode))

  (use-package dtrt-indent
    :hook (change-major-mide-after-body . dtrt-indent-global-mode)
    :init
    (setq dtrt-indent-run-after-smie t)
    :config
    (push '(t tab-width) dtrt-indent-hook-generic-mapping-list))

  (use-package yasnippet
    :hook ((prog-mode text-mode) . yas-minor-mode)
    :after-call vl-first-input-hook)

  (use-package yasnippet-snippets
    :after yasnippet)
#+end_src
*** LSP
#+begin_src emacs-lisp
  (use-package lsp-mode
    :commands (lsp lsp-deferred vl--lsp-mode-setup-completion)
    :hook
    (lsp-mode . lsp-enable-which-key-integration)
    (lsp-completion-mode . vl--lsp-mode-setup-completion)
    :custom
    (lsp-completion-provider :none)
    (lsp-keymap-prefix "s-a")
    (lsp-signature-render-documentation nil)
    :config
    (defun vl--lsp-mode-setup-completion ()
      (setf (alist-get 'styles (alist-get 'lsp-capf completion-category-defaults))
            '(orderless)))
    (defun vl--orderless-dispatch-flex-first (_pattern index _total)
      (and (eq index 0) 'orderless-flex))
    (add-hook 'orderless-style-dispatchers #'vl--orderless-dispatch-flex-first nil 'local)

    (setq-local completion-at-point-functions (list (cape-capf-buster #'lsp-completion-at-point))))

  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode)
    :bind ("M-h" . lsp-ui-doc-show)
    :config
    (setq lsp-ui-doc-show-with-cursor nil
          lsp-ui-doc-show-with-mouse nil
          lsp-ui-doc-position 'top ;; 'at-point
          lsp-ui-sideline-enable t
          lsp-ui-sideline-show-hover nil
          lsp-ui-sideline-ignore-duplicate t
          lsp-ui-sideline-delay 0.4
          lsp-ui-sideline-actions-icon lsp-ui-sideline-actions-icon-default
          lsp-ui-doc-max-width 80
          lsp-ui-doc-max-height 40
          lsp-ui-peek-enable t
          lsp-headerline-breadcrumb-enable nil
          lsp-lens-enable t
          lsp-file-watch-threshold 1000000))

  (use-package lsp-treemacs
    :after (treemacs lsp-mode))

  (use-package dap-mode
    :after lsp-mode
    :hook (lsp-mode . dap-mode)
    :config
    (add-hook 'dap-stopped-hook
              (lambda (arg) (call-interactively #'dap-hydra))))
#+end_src
*** ELISP
#+begin_src emacs-lisp
  (use-package elisp-mode
    :ensure nil
    :defer t
    :hook (emacs-lisp-mode
           . (lambda ()
               (setq tab-width 2))))

  (use-package aggressive-indent
    :hook (emacs-lisp-mode . aggressive-indent-mode))
#+end_src
*** Bash/sh

#+begin_src emacs-lisp
  (use-package prog-mode
    :ensure nil
    :hook (sh-mode . lsp-deferred))
#+end_src

*** C/C++

#+begin_src emacs-lisp
  (use-package prog-mode
    :ensure nil
    :hook ((c-mode c++mode) . lsp-deferred))
#+end_src

*** CSS/LessCSS/SASS/SCSS
#+begin_src emacs-lisp
  (use-package css-mode
    :ensure nil
    :hook (css-mode . lsp-deferred))

  (use-package scss-mode
    :ensure nil
    :hook (scss-mode . lsp-deferred))

  (use-package sass-mode
    :hook (sass-mode .lsp-deferred))
#+end_src

*** Docker

#+begin_src emacs-lisp
  (use-package docker
    :defer t)
  (use-package docker-tramp
    :defer t)
  (use-package dockerfile-mode
    :mode "\\Dockerfile\\'")
#+end_src

*** F#

#+begin_src emacs-lisp
  (use-package fsharp-mode
    :hook (fsharp-mode . lsp-deferred))
#+end_src

*** Graphql
#+begin_src emacs-lisp
  (use-package graphql-mode
    :mode "\\.graphql\\'")
#+end_src
*** HTML & Templating

#+begin_src emacs-lisp
  (use-package web-mode
    :mode "\\.phtml\\'"
    :mode "\\.tpl\\.php\\'"
    :mode "\\.[agj]sp\\'"
    :mode "\\.as[cp]x\\'"
    :mode "\\.erb\\'"
    :mode "\\.mustache\\'"
    :mode "\\.djhtml\\'"
    :hook (web-mode . lsp-deferred))
#+end_src

*** Just

#+begin_src emacs-lisp
  (use-package just-mode
    :defer t)
#+end_src

*** Lua

#+begin_src emacs-lisp
  (use-package lua-mode
    :mode "\\.lua\\'"
    :hook (lua-mode . lsp-deferred))
#+end_src

*** Json

#+begin_src emacs-lisp
  (use-package json-mode
    :mode "\\.json\\'"
    ;;:hook (json-mode . lsp-deferred)
    )
#+end_src

*** JavaScript/TypeScript

#+begin_src emacs-lisp
  (use-package js-mode
    :ensure nil
    :init (setq js-indent-level 2)
    :hook (js-mode . lsp-deferred))

  (use-package js2-mode
    :hook (js-mode . js2-minor-mode)
    :init
    (setq js-chain-indent t
          ;; Don't mishighlight shebang lines
          js2-skip-preprocessor-directives t
          ;; let flycheck handle this
          js2-mode-show-parse-errors nil
          js2-mode-show-strict-warnings nil
          ;; Flycheck provides these features, so disable them: conflicting with
          ;; the eslint settings.
          js2-strict-missing-semi-warning nil
          ;; maximum fontification
          js2-highlight-level 3
          js2-idle-timer-delay 0.15))

  (use-package typescript-mode
    :mode "\\.tsx?\\'"
    :hook (typescript-mode . lsp-deferred))
#+end_src
*** Nix
#+begin_src emacs-lisp
  (use-package nix-mode
    :hook (nix-mode . lsp-deferred)
    :mode "\\.nix\\'"
    :config
    (setq tab-width 2))
#+end_src
*** Julia
#+begin_src emacs-lisp
  (use-package julia-mode
    :interpreter "julia"
    :mode "\\.jl\\'")
  (use-package julia-repl
    :hook (julia-mode . julia-repl-mode))

  (use-package lsp-julia
    :defer t
    :hook (julia-mode . (lambda ()
                          (require 'lsp-julia)
                          (lsp-deferred)))
    :config
    (defun lsp-julia--get-root ()
      "Get the (Julia) project root directory of the current file."
      (concat "\""
              (expand-file-name
               (or (locate-dominating-file buffer-file-name "Project.toml")
                   lsp-julia-default-environment))
              "\""))

    (let ((lsp-orig-path (expand-file-name "Project.toml" (expand-file-name "languageserver" lsp-julia--self-path))))
      (unless (file-exists-p lsp-julia-package-dir)
        (make-directory lsp-julia-package-dir))
      (f-write (f-read lsp-orig-path) 'utf-8 (expand-file-name "Project.toml" lsp-julia-package-dir)))
    :custom
    (lsp-julia-package-dir (expand-file-name "lsp-julia" no-littering-var-directory))
    (lsp-julia-default-environment "~/.julia/environments/v1.6"))
#+end_src
*** Python
#+begin_src emacs-lisp
  (use-package lsp-pyright
    :defer t
    :hook (python-mode . (lambda ()
                           (smart-newline-mode -1)
                           (require 'lsp-pyright)
                           (lsp-deferred))))
  (use-package pyvenv
    :hook (python-mode . pyvenv-tracking-mode))
#+end_src
*** Rust
#+begin_src emacs-lisp
  (use-package lsp-mode
    :init
    (defun vl-lsp-extend-semantic-tokens ()
               (require 'lsp-semantic-tokens)
               (add-to-list 'lsp-semantic-token-modifier-faces
                            '("mutable" . underline))
               (remove-hook 'lsp-before-initialize-hook 'vl-lsp-extend-semantic-tokens))
    :hook (lsp-before-initialize . vl-lsp-extend-semantic-tokens))

  (use-package rustic
    :defer t
    :after (lsp-mode flycheck)
    :mode ("\\.rs$" . rustic-mode)
    :commands rustic-run-cargo-command rustic-cargo-outdated
    :general
    (local-leader-prefix
      :keymaps 'rustic-mode-map
      "i" '(lsp-rust-analyzer-inlay-hints-mode :wk "toggle-inlay-hints")
      "R" '(lsp-rust-analyzer-reload-workspace :wk "reload-workspace")
      "t" '(lsp-rust-analyzer-related-tests :wk "related-tests")
      "T" '(rustic-cargo-test :wk "cargo-test")
      )
    (:keymaps 'rustic-mode-map
              "M-<up>" 'lsp-rust-analyzer-move-item-up
              "M-<down>" 'lsp-rust-analyzer-move-item-down)
    :init
    (setq rust-indent-method-chain t
          lsp-rust-analyzer-cargo-watch-command "clippy"
          lsp-rust-analyzer-highlighting-strings t
          lsp-rust-analyzer-server-display-inlay-hints t
          lsp-rust-analyzer-display-chaining-hints t
          lsp-rust-analyzer-display-parameter-hints t
          lsp-rust-analyzer-diagnostics-disabled ["unresolved-macro-call" "unresolved-proc-macro"]
          lsp-enable-semantic-highlighting t
          lsp-semantic-tokens-apply-modifiers t)
    :config
    (with-eval-after-load 'rustic-flycheck
      (add-to-list 'flycheck-checkers 'rustic-clippy))
    (with-eval-after-load 'dap-mode
      (require 'dap-cpptools)))
#+end_src
*** Markdown
#+begin_src emacs-lisp
  (use-package markdown-mode
    :hook (markdown-mode . lsp-deferred)
    :config
    (add-to-list 'markdown-code-lang-modes '("rust" . rustic-mode)))
  (use-package edit-indirect
    :defer t)
  (use-package grip-mode
    :defer t)
  (use-package evil-markdown
    :hook (markdown-mode . evil-markdown-mode))
#+end_src
*** YAML

#+begin_src emacs-lisp
  (use-package yaml-mode
    :defer t)
  (use-package gitlab-ci-mode
    :defer t)
#+end_src

*** Zig
#+begin_src emacs-lisp
  (use-package zig-mode
    :hook (zig-mode . lsp-deferred))
#+end_src
*** Misc
#+begin_src emacs-lisp
  (use-package direnv
    :hook (after-init . direnv-mode)
    :init
    (setq direnv-always-show-summary nil))

  (use-package flycheck
    :hook (vl-first-input . global-flycheck-mode))

  (use-package flycheck-posframe
    :hook (flycheck-mode . flycheck-posframe-mode))

  (use-package flyspell
    :ensure nil
    :defer 5
    :hook (text-mode . flyspell-mode)
    :init
    (setq ;; ispell-program-name "hunspell"
          ispell-dictionary "en_US,hu_HU")
    :config
    (ispell-set-spellchecker-params)
    (ispell-hunspell-add-multi-dic ispell-dictionary))

  (use-package langtool
    :defer t)

  (use-package cape
    :after-call vl-first-input-hook
    :config
    (add-to-list 'completion-at-point-functions #'cape-file))

  (use-package corfu
    :hook (vl-first-input . corfu-global-mode)
    :bind (:map corfu-map
           ("TAB" . corfu-next)
           ([tab] . corfu-next)
           ("S-TAB" . corfu-previous)
           ([backtab] . corfu-previous))
    :init
    (setq tab-always-indent 'complete))
#+end_src

** Email

#+begin_src emacs-lisp
  (use-package mu4e
    :ensure nil ;; installed as part of the =mu= package
    :commands mu4e
    :custom
     (mue4e-headers-skip-duplicates  t)
     (mu4e-view-show-images t)
     (mu4e-view-show-addresses t)
     (mu4e-compose-format-flowed nil)
     (mu4e-date-format "%y-%m-%d")
     (mu4e-headers-date-format "%Y-%m-%d")
     (mu4e-change-filenames-when-moving t)
     (mu4e-attachments-dir "~/Downloads")
     (mu4e-context-policy 'pick-first)
     (mu4e-compose-context-policy 'ask-if-none)
     (mu4e-completing-read-function #'completing-read)
     (message-send-mail-function 'smtpmail-send-it))

  (use-package mu4e-thread-folding
    :hook (mu4e-headers-mode . mu4e-thread-folding-mode)
    :config
    (add-to-list 'mu4e-header-info-custom
                 '(:empty . (:name "Empty"
                                   :shortname ""
                                   :function (lambda (msg) "  "))))
    (setq mu4e-headers-fields '((:empty         .    2)
                                (:human-date    .   12)
                                (:flags         .    6)
                                (:mailing-list  .   10)
                                (:from          .   22)
                                (:subject       .   nil))))
#+end_src
